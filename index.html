<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Serpent - Modern Snake Game</title>
    <meta name="description" content="Serpent – a modern, realistic Snake game with seasonal themes, animated food, and 10 levels of increasing challenge.">
    <meta property="og:title" content="Serpent – Modern Snake Game">
    <meta property="og:description" content="Play Serpent, a beautifully rendered Snake game with seasonal themes, animated food types, and 10 challenging levels.">
    <meta property="og:type" content="website">
    <meta name="theme-color" content="#0f2027">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 10px;
            box-sizing: border-box;
        }

        .game-container {
            background: linear-gradient(145deg, #1a1a1a, #2d2d2d);
            padding: 30px;
            border-radius: 25px;
            box-shadow:
                0 40px 80px rgba(0, 0, 0, 0.9),
                inset 0 2px 0 rgba(255, 255, 255, 0.1);
            border: 4px solid #444;
            max-width: 820px;
            width: 100%;
        }

        .game-wrapper {
            background: linear-gradient(135deg, #1e3c28 0%, #2d5a3d 100%);
            border: 12px solid #0a0a0a;
            border-radius: 15px;
            padding: 10px;
            box-shadow:
                inset 0 0 50px rgba(0, 0, 0, 0.6),
                0 10px 30px rgba(0, 0, 0, 0.7);
        }

        .info-bar {
            display: flex;
            justify-content: space-between;
            padding: 15px 20px;
            background: linear-gradient(180deg, rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.5));
            margin-bottom: 10px;
            font-weight: 600;
            color: #fff;
            font-size: 16px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
        }

        .info-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .label {
            font-size: 11px;
            opacity: 0.7;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .value {
            font-size: 20px;
            font-weight: bold;
            color: #7CFC00;
            text-shadow: 0 0 10px rgba(124, 252, 0, 0.5);
        }

        canvas {
            display: block;
            border-radius: 10px;
            box-shadow:
                inset 0 0 30px rgba(0, 0, 0, 0.3),
                0 10px 25px rgba(0, 0, 0, 0.6);
            touch-action: none;
        }

        .controls {
            margin-top: 30px;
            text-align: center;
            color: #fff;
        }

        .controls h3 {
            margin-bottom: 15px;
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.8);
            font-size: 22px;
            letter-spacing: 2px;
        }

        .controls p {
            margin: 8px 0;
            font-size: 14px;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.6);
            opacity: 0.9;
        }

        .button-container {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }

        button {
            padding: 16px 32px;
            background: linear-gradient(135deg, #7CFC00, #32CD32);
            border: none;
            border-radius: 12px;
            color: #000;
            font-family: 'Segoe UI', sans-serif;
            font-weight: bold;
            cursor: pointer;
            font-size: 15px;
            transition: all 0.3s ease;
            box-shadow:
                0 8px 16px rgba(124, 252, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        button:hover {
            background: linear-gradient(135deg, #90FF10, #40E040);
            transform: translateY(-4px) scale(1.05);
            box-shadow:
                0 12px 24px rgba(124, 252, 0, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.4);
        }

        button:active {
            transform: translateY(-2px) scale(1.02);
        }

        button:focus {
            outline: 3px solid #7CFC00;
            outline-offset: 2px;
        }

        .overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(20, 40, 20, 0.95));
            padding: 40px 50px;
            border-radius: 20px;
            text-align: center;
            color: #fff;
            display: none;
            border: 4px solid #7CFC00;
            box-shadow:
                0 20px 60px rgba(0, 0, 0, 0.9),
                inset 0 2px 0 rgba(124, 252, 0, 0.2);
            backdrop-filter: blur(10px);
        }

        .overlay h2 {
            margin-bottom: 20px;
            font-size: 42px;
            text-shadow:
                2px 2px 4px rgba(0, 0, 0, 0.8),
                0 0 20px rgba(124, 252, 0, 0.6);
            color: #7CFC00;
        }

        .overlay p {
            margin: 15px 0;
            font-size: 18px;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.8);
        }

        .legend {
            margin-top: 25px;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 12px;
            font-size: 14px;
            border: 2px solid rgba(124, 252, 0, 0.3);
        }

        .legend-item {
            margin: 8px 0;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .pulsing {
            animation: pulse 2s infinite;
        }

        @keyframes scorePop {
            0%   { transform: scale(1);    color: #7CFC00; }
            40%  { transform: scale(1.45); color: #ffffff; text-shadow: 0 0 18px #fff, 0 0 8px #7CFC00; }
            100% { transform: scale(1);    color: #7CFC00; }
        }

        .score-pop {
            animation: scorePop 0.35s ease-out;
        }

        @keyframes levelFlash {
            0%   { background: rgba(124,252,0,0.18); }
            100% { background: transparent; }
        }

        .level-flash {
            animation: levelFlash 0.6s ease-out;
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* ---- Mobile responsive scaling ---- */
        @media (max-width: 780px) {
            body {
                align-items: flex-start;
                padding: 10px;
            }
            .game-container {
                padding: 12px;
                border-radius: 15px;
            }
            .game-wrapper {
                border-width: 6px;
                padding: 4px;
            }
            canvas {
                width: 100% !important;
                height: auto !important;
            }
            .info-bar {
                padding: 8px 12px;
                font-size: 13px;
            }
            .value {
                font-size: 16px;
            }
            .button-container {
                flex-wrap: wrap;
            }
            button {
                padding: 12px 18px;
                font-size: 13px;
            }
            .overlay {
                padding: 24px 28px;
                width: 90%;
            }
            .overlay h2 {
                font-size: 30px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container" role="main" aria-label="Snake Game">
        <div class="game-wrapper">
            <div class="info-bar" role="status" aria-live="polite">
                <div class="info-item">
                    <span class="label" id="score-label">Score</span>
                    <span class="value" id="score" aria-labelledby="score-label">0</span>
                </div>
                <div class="info-item">
                    <span class="label" id="level-label">Level</span>
                    <span class="value" id="level" aria-labelledby="level-label">1</span>
                </div>
                <div class="info-item">
                    <span class="label" id="highscore-label">High Score</span>
                    <span class="value" id="highScore" aria-labelledby="highscore-label">0</span>
                </div>
            </div>
            <canvas id="gameCanvas" width="700" height="700" aria-label="Game canvas - use arrow keys to control the snake" tabindex="0"></canvas>

            <div class="overlay" id="startScreen" role="dialog" aria-labelledby="start-title">
                <h2 id="start-title">SERPENT</h2>
                <p style="font-size: 16px; opacity: 0.8;">Modern Realistic Snake Game</p>
                <p style="margin-top: 25px;">Press SPACE or tap START to begin</p>
                <div class="legend">
                    <div class="legend-item">Rabbit: 50 points (Rare, Animated)</div>
                    <div class="legend-item">Mouse: 20 points (Common)</div>
                    <div class="legend-item">Apple: 10 points (Common)</div>
                </div>
            </div>

            <div class="overlay" id="gameOverScreen" role="dialog" aria-labelledby="gameover-title">
                <h2 id="gameover-title">GAME OVER</h2>
                <p>Final Score: <span id="finalScore">0</span></p>
                <p>Level Reached: <span id="finalLevel">1</span></p>
                <p style="margin-top: 25px;" class="pulsing">Press SPACE or tap RESTART</p>
            </div>
        </div>

        <div class="controls">
            <h3>CONTROLS</h3>
            <p>Arrow Keys / Swipe - Move Snake</p>
            <p>SPACE - Start / Pause / Resume</p>
            <div class="button-container">
                <button id="startBtn" aria-label="Start game">START</button>
                <button id="pauseBtn" aria-label="Pause game">PAUSE</button>
                <button id="restartBtn" aria-label="Restart game">RESTART</button>
            </div>
        </div>
        <div class="sr-only" id="game-announcer" aria-live="assertive"></div>
    </div>

    <script>
    'use strict';

    (function() {
        // ==================== CONSTANTS ====================
        const CANVAS_SIZE = 700;
        const GRID_SIZE = 25;
        const TILE_SIZE = CANVAS_SIZE / GRID_SIZE;
        const GRASS_COUNT = 400;
        const SHRUB_COUNT = 25;
        const SHRUB_EDGE_MARGIN = 80;
        const PARTICLE_COUNT = 40;
        const LIGHT_PATCH_COUNT = 5;
        const MAX_FOOD_SPAWN_ATTEMPTS = 100;
        const IDLE_FRAME_INTERVAL = 50;
        const MAX_JAW_ANGLE = 0.55;   // radians (~31°) — how wide the jaw opens
        const JAW_OPEN_DISTANCE = 4;  // grid tiles within which jaw starts to open

        const FOOD_TYPES = {
            APPLE: { points: 10, probability: 0.6 },
            MOUSE: { points: 20, probability: 0.3 },
            RABBIT: { points: 50, probability: 0.1 }
        };

        const LEVELS = [
            { level: 1, speed: 140, pointsNeeded: 100, season: 'spring' },
            { level: 2, speed: 125, pointsNeeded: 250, season: 'summer' },
            { level: 3, speed: 110, pointsNeeded: 400, season: 'autumn' },
            { level: 4, speed: 95, pointsNeeded: 600, season: 'winter' },
            { level: 5, speed: 80, pointsNeeded: 850, season: 'spring' },
            { level: 6, speed: 70, pointsNeeded: 1150, season: 'summer' },
            { level: 7, speed: 60, pointsNeeded: 1500, season: 'autumn' },
            { level: 8, speed: 50, pointsNeeded: 1900, season: 'winter' },
            { level: 9, speed: 40, pointsNeeded: 2400, season: 'mystic' },
            { level: 10, speed: 30, pointsNeeded: Infinity, season: 'void' }
        ];

        const SEASONS = {
            spring: {
                ground: ['#7cb342', '#8bc34a', '#9ccc65'],
                grass: '#4caf50',
                accent: '#66bb6a',
                particle: '#ffb6c1'
            },
            summer: {
                ground: ['#9ccc65', '#aed581', '#c5e1a5'],
                grass: '#7cb342',
                accent: '#8bc34a',
                particle: '#ffd54f'
            },
            autumn: {
                ground: ['#a1887f', '#bcaaa4', '#d7ccc8'],
                grass: '#8d6e63',
                accent: '#a1887f',
                particle: '#ff8a65'
            },
            winter: {
                ground: ['#cfd8dc', '#eceff1', '#ffffff'],
                grass: '#b0bec5',
                accent: '#cfd8dc',
                particle: '#e1f5fe'
            },
            mystic: {
                ground: ['#4db6ac', '#26a69a', '#009688'],
                grass: '#00897b',
                accent: '#26a69a',
                particle: '#00e5ff'
            },
            void: {
                ground: ['#424242', '#616161', '#757575'],
                grass: '#212121',
                accent: '#424242',
                particle: '#9e9e9e'
            }
        };

        // ==================== DOM ELEMENTS ====================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Canvas context fallback check
        if (!ctx) {
            document.body.innerHTML = '<p style="color: white; text-align: center; margin-top: 50px;">Your browser does not support HTML5 Canvas. Please use a modern browser.</p>';
            return;
        }

        // Handle GPU/context loss (e.g. low memory, tab switching on mobile)
        canvas.addEventListener('contextlost', function(e) {
            e.preventDefault();
            if (animationId) { cancelAnimationFrame(animationId); animationId = null; }
            if (idleAnimationId) { cancelAnimationFrame(idleAnimationId); idleAnimationId = null; }
            announce('Display connection lost. Please wait...');
        }, false);

        canvas.addEventListener('contextrestored', function() {
            preRenderBackground();
            draw();
            if (gameState !== 'playing') startIdleAnimation();
            announce('Display restored.');
        }, false);

        const scoreEl = document.getElementById('score');
        const levelEl = document.getElementById('level');
        const highScoreEl = document.getElementById('highScore');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const finalScoreEl = document.getElementById('finalScore');
        const finalLevelEl = document.getElementById('finalLevel');
        const startBtn = document.getElementById('startBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const restartBtn = document.getElementById('restartBtn');
        const announcer = document.getElementById('game-announcer');

        // Offscreen canvas for pre-rendered background
        const bgCanvas = document.createElement('canvas');
        bgCanvas.width = CANVAS_SIZE;
        bgCanvas.height = CANVAS_SIZE;
        const bgCtx = bgCanvas.getContext('2d');

        // ==================== VISUAL EFFECT STATE ====================
        let levelUpBurst = null;   // { x, y, radius, maxRadius, alpha }
        let deathFlashAlpha = 0;   // 0–1, drives the red overlay on death

        // ==================== GAME STATE ====================
        let snake = [];
        let direction = { x: 1, y: 0 };
        let nextDirection = { x: 1, y: 0 };
        let food = {};
        let score = 0;
        function loadHighScore() {
            try {
                return parseInt(localStorage.getItem('serpentHighScore'), 10) || 0;
            } catch (e) {
                return 0;
            }
        }
        function saveHighScore(val) {
            try {
                localStorage.setItem('serpentHighScore', val);
            } catch (e) { /* quota exceeded or private/incognito mode */ }
        }
        let highScore = loadHighScore();
        let currentLevel = 1;
        let gameState = 'start'; // 'start', 'playing', 'paused', 'gameover'
        let animationFrame = 0;
        let particles = [];
        let shrubs = [];
        let lastUpdateTime = 0;
        let accumulatedTime = 0;
        let animationId = null;
        let idleAnimationId = null;
        let jawAngle = 0; // current jaw-open angle in radians

        // Touch handling state
        let touchStartX = 0;
        let touchStartY = 0;
        const SWIPE_THRESHOLD = 30;

        // ==================== INITIALIZATION ====================
        highScoreEl.textContent = highScore;
        startScreen.style.display = 'block';

        // ==================== UTILITY FUNCTIONS ====================
        function shadeColor(color, percent) {
            const num = parseInt(color.replace('#', ''), 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.max(0, Math.min(255, (num >> 16) + amt));
            const G = Math.max(0, Math.min(255, ((num >> 8) & 0x00FF) + amt));
            const B = Math.max(0, Math.min(255, (num & 0x0000FF) + amt));
            return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
        }

        function getSeasonColors(season) {
            return SEASONS[season] || SEASONS.spring;
        }

        function announce(message) {
            announcer.textContent = message;
        }

        // ==================== VEGETATION GENERATION ====================
        function generateVegetation() {
            shrubs = [];
            const colors = getSeasonColors(LEVELS[currentLevel - 1].season);
            const season = LEVELS[currentLevel - 1].season;

            for (let i = 0; i < SHRUB_COUNT; i++) {
                const edge = Math.floor(Math.random() * 4);
                let x, y;

                if (edge === 0) {
                    x = Math.random() * CANVAS_SIZE;
                    y = Math.random() * SHRUB_EDGE_MARGIN;
                } else if (edge === 1) {
                    x = CANVAS_SIZE - SHRUB_EDGE_MARGIN + Math.random() * SHRUB_EDGE_MARGIN;
                    y = Math.random() * CANVAS_SIZE;
                } else if (edge === 2) {
                    x = Math.random() * CANVAS_SIZE;
                    y = CANVAS_SIZE - SHRUB_EDGE_MARGIN + Math.random() * SHRUB_EDGE_MARGIN;
                } else {
                    x = Math.random() * SHRUB_EDGE_MARGIN;
                    y = Math.random() * CANVAS_SIZE;
                }

                let shrubColor = colors.grass;
                if (season === 'autumn') {
                    shrubColor = Math.random() > 0.5 ? '#8b4513' : colors.grass;
                } else if (season === 'winter') {
                    shrubColor = '#7a9a7a';
                }

                const circles = [];
                for (let j = 0; j < 6; j++) {
                    const offsetX = (Math.random() - 0.5) * 30 * 0.6;
                    const offsetY = (Math.random() - 0.5) * 30 * 0.4;
                    const size = 30 * 0.3 + Math.random() * 30 * 0.3;
                    circles.push({ offsetX, offsetY, size });
                }

                shrubs.push({
                    x: x,
                    y: y,
                    size: 25 + Math.random() * 30,
                    color: shrubColor,
                    circles: circles
                });
            }

            // Pre-render background after generating vegetation
            preRenderBackground();
        }

        // ==================== PRE-RENDERED BACKGROUND ====================
        function preRenderBackground() {
            const colors = getSeasonColors(LEVELS[currentLevel - 1].season);

            // Clear background canvas
            bgCtx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

            // Radial gradient for depth
            const gradient = bgCtx.createRadialGradient(
                CANVAS_SIZE / 2, CANVAS_SIZE / 2, 0,
                CANVAS_SIZE / 2, CANVAS_SIZE / 2, CANVAS_SIZE / 1.3
            );
            gradient.addColorStop(0, colors.ground[1]);
            gradient.addColorStop(0.7, colors.ground[0]);
            gradient.addColorStop(1, colors.ground[0]);
            bgCtx.fillStyle = gradient;
            bgCtx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

            // Pre-render grass with fixed positions (seeded by level)
            const grassPositions = [];
            const seed = currentLevel * 12345;
            for (let i = 0; i < GRASS_COUNT; i++) {
                const pseudoRandom1 = ((seed + i * 7919) % 10000) / 10000;
                const pseudoRandom2 = ((seed + i * 7927) % 10000) / 10000;
                const pseudoRandom3 = ((seed + i * 7933) % 10000) / 10000;
                const pseudoRandom4 = ((seed + i * 7937) % 10000) / 10000;

                grassPositions.push({
                    x: pseudoRandom1 * CANVAS_SIZE,
                    y: pseudoRandom2 * CANVAS_SIZE,
                    length: 8 + pseudoRandom3 * 12,
                    angle: pseudoRandom4 * Math.PI * 2
                });
            }

            grassPositions.forEach(grass => {
                bgCtx.save();
                bgCtx.translate(grass.x, grass.y);
                bgCtx.rotate(grass.angle);

                const grassGradient = bgCtx.createLinearGradient(0, 0, 0, grass.length);
                grassGradient.addColorStop(0, colors.grass);
                grassGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

                bgCtx.strokeStyle = grassGradient;
                bgCtx.lineWidth = 1.5;
                bgCtx.lineCap = 'round';
                bgCtx.globalAlpha = 0.3;
                bgCtx.beginPath();
                bgCtx.moveTo(0, 0);
                bgCtx.lineTo(0, grass.length);
                bgCtx.stroke();
                bgCtx.restore();
            });

            // Pre-render shrubs
            shrubs.forEach(shrub => {
                // Shadow
                bgCtx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                bgCtx.beginPath();
                bgCtx.ellipse(shrub.x, shrub.y + shrub.size * 0.3, shrub.size * 0.7, shrub.size * 0.15, 0, 0, Math.PI * 2);
                bgCtx.fill();

                shrub.circles.forEach(circle => {
                    const circleGradient = bgCtx.createRadialGradient(
                        shrub.x + circle.offsetX - circle.size * 0.3,
                        shrub.y + circle.offsetY - circle.size * 0.3,
                        0,
                        shrub.x + circle.offsetX,
                        shrub.y + circle.offsetY,
                        circle.size
                    );
                    circleGradient.addColorStop(0, shrub.color);
                    circleGradient.addColorStop(1, shadeColor(shrub.color, -35));

                    bgCtx.fillStyle = circleGradient;
                    bgCtx.beginPath();
                    bgCtx.arc(shrub.x + circle.offsetX, shrub.y + circle.offsetY, circle.size, 0, Math.PI * 2);
                    bgCtx.fill();
                });
            });

            // Pre-render light patches with fixed positions
            for (let i = 0; i < LIGHT_PATCH_COUNT; i++) {
                const pseudoRandom1 = ((currentLevel * 54321 + i * 7919) % 10000) / 10000;
                const pseudoRandom2 = ((currentLevel * 54321 + i * 7927) % 10000) / 10000;
                const pseudoRandom3 = ((currentLevel * 54321 + i * 7933) % 10000) / 10000;

                const x = pseudoRandom1 * CANVAS_SIZE;
                const y = pseudoRandom2 * CANVAS_SIZE;
                const size = 100 + pseudoRandom3 * 200;

                const lightGradient = bgCtx.createRadialGradient(x, y, 0, x, y, size);
                lightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.05)');
                lightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

                bgCtx.fillStyle = lightGradient;
                bgCtx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            }

            // Pebbles / stones scattered on the ground
            for (let i = 0; i < 40; i++) {
                const pr1 = ((currentLevel * 44444 + i * 6197) % 10000) / 10000;
                const pr2 = ((currentLevel * 44444 + i * 6199) % 10000) / 10000;
                const pr3 = ((currentLevel * 44444 + i * 6203) % 10000) / 10000;
                const pr4 = ((currentLevel * 44444 + i * 6211) % 10000) / 10000;
                const px = pr1 * CANVAS_SIZE;
                const py = pr2 * CANVAS_SIZE;
                const pSz = 3.5 + pr3 * 7;
                const pAng = pr4 * Math.PI;
                const pG = bgCtx.createRadialGradient(px - pSz * 0.3, py - pSz * 0.3, 0, px, py, pSz);
                pG.addColorStop(0, '#c8c5b8');
                pG.addColorStop(0.7, '#9a9888');
                pG.addColorStop(1, '#6a6860');
                bgCtx.fillStyle = pG;
                bgCtx.globalAlpha = 0.55 + pr3 * 0.3;
                bgCtx.beginPath();
                bgCtx.ellipse(px, py, pSz, pSz * 0.62, pAng, 0, Math.PI * 2);
                bgCtx.fill();
                bgCtx.strokeStyle = 'rgba(70,65,55,0.28)';
                bgCtx.lineWidth = 0.5;
                bgCtx.stroke();
            }
            bgCtx.globalAlpha = 1;

            // Seasonal ground details
            const detailSeason = LEVELS[currentLevel - 1].season;
            if (detailSeason === 'autumn') {
                // Fallen leaves
                const leafColors = ['#d84315', '#e65100', '#f57c00', '#bf360c', '#8d6e63'];
                for (let i = 0; i < 90; i++) {
                    const r1 = ((currentLevel * 13579 + i * 3137) % 10000) / 10000;
                    const r2 = ((currentLevel * 13579 + i * 3163) % 10000) / 10000;
                    const r3 = ((currentLevel * 13579 + i * 3167) % 10000) / 10000;
                    const r4 = ((currentLevel * 13579 + i * 3169) % 10000) / 10000;
                    bgCtx.save();
                    bgCtx.translate(r1 * CANVAS_SIZE, r2 * CANVAS_SIZE);
                    bgCtx.rotate(r4 * Math.PI * 2);
                    bgCtx.fillStyle = leafColors[Math.floor(r3 * 5)];
                    bgCtx.globalAlpha = 0.45 + r3 * 0.3;
                    bgCtx.beginPath();
                    bgCtx.ellipse(0, 0, 5 + r3 * 3, 3 + r3 * 2, 0, 0, Math.PI * 2);
                    bgCtx.fill();
                    bgCtx.restore();
                }
            } else if (detailSeason === 'winter') {
                // Snow drifts
                for (let i = 0; i < 45; i++) {
                    const r1 = ((currentLevel * 22222 + i * 4157) % 10000) / 10000;
                    const r2 = ((currentLevel * 22222 + i * 4159) % 10000) / 10000;
                    const r3 = ((currentLevel * 22222 + i * 4177) % 10000) / 10000;
                    const sx = r1 * CANVAS_SIZE;
                    const sy = r2 * CANVAS_SIZE;
                    const snowR = 18 + r3 * 38;
                    const snowG = bgCtx.createRadialGradient(sx, sy, 0, sx, sy, snowR);
                    snowG.addColorStop(0, 'rgba(255,255,255,0.55)');
                    snowG.addColorStop(1, 'rgba(255,255,255,0)');
                    bgCtx.fillStyle = snowG;
                    bgCtx.beginPath();
                    bgCtx.arc(sx, sy, snowR, 0, Math.PI * 2);
                    bgCtx.fill();
                }
            } else if (detailSeason === 'spring') {
                // Wildflowers
                const flowerColors = ['#f48fb1', '#ffcc80', '#ce93d8', '#81d4fa', '#a5d6a7'];
                for (let i = 0; i < 55; i++) {
                    const r1 = ((currentLevel * 33333 + i * 5171) % 10000) / 10000;
                    const r2 = ((currentLevel * 33333 + i * 5179) % 10000) / 10000;
                    const r3 = ((currentLevel * 33333 + i * 5189) % 10000) / 10000;
                    bgCtx.fillStyle = flowerColors[Math.floor(r3 * 5)];
                    bgCtx.globalAlpha = 0.65;
                    bgCtx.beginPath();
                    bgCtx.arc(r1 * CANVAS_SIZE, r2 * CANVAS_SIZE, 2.5, 0, Math.PI * 2);
                    bgCtx.fill();
                    bgCtx.fillStyle = '#fff9c4';
                    bgCtx.globalAlpha = 0.85;
                    bgCtx.beginPath();
                    bgCtx.arc(r1 * CANVAS_SIZE, r2 * CANVAS_SIZE, 0.9, 0, Math.PI * 2);
                    bgCtx.fill();
                }
            } else if (detailSeason === 'void') {
                // Cracked earth lines
                bgCtx.globalAlpha = 0.22;
                bgCtx.strokeStyle = '#9e9e9e';
                bgCtx.lineWidth = 1;
                for (let i = 0; i < 20; i++) {
                    const r1 = ((currentLevel * 55555 + i * 7213) % 10000) / 10000;
                    const r2 = ((currentLevel * 55555 + i * 7219) % 10000) / 10000;
                    const r3 = ((currentLevel * 55555 + i * 7229) % 10000) / 10000;
                    const vLen = 30 + r3 * 80;
                    const vAng = r3 * Math.PI;
                    const vx = r1 * CANVAS_SIZE;
                    const vy = r2 * CANVAS_SIZE;
                    bgCtx.beginPath();
                    bgCtx.moveTo(vx, vy);
                    bgCtx.lineTo(vx + Math.cos(vAng) * vLen, vy + Math.sin(vAng) * vLen);
                    bgCtx.stroke();
                }
            }
            bgCtx.globalAlpha = 1;
        }

        function drawBackground() {
            // Simply draw the pre-rendered background
            ctx.drawImage(bgCanvas, 0, 0);
        }

        // ==================== PARTICLES ====================
        function initParticles() {
            particles = [];
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                particles.push({
                    x: Math.random() * CANVAS_SIZE,
                    y: Math.random() * CANVAS_SIZE,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: 0.3 + Math.random() * 0.7,
                    size: 2 + Math.random() * 4,
                    opacity: 0.3 + Math.random() * 0.5,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.05
                });
            }
        }

        function updateParticles() {
            particles.forEach(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.rotation += p.rotationSpeed;

                if (p.y > CANVAS_SIZE) {
                    p.y = -10;
                    p.x = Math.random() * CANVAS_SIZE;
                }
                if (p.x < -10) p.x = CANVAS_SIZE + 10;
                if (p.x > CANVAS_SIZE + 10) p.x = -10;
            });
        }

        // Cache a small offscreen canvas per season color to stamp particles cheaply
        const particleCache = {};
        function getParticleStamp(color, maxSize) {
            const key = color + maxSize;
            if (particleCache[key]) return particleCache[key];
            const size = Math.ceil(maxSize) * 2 + 2;
            const stamp = document.createElement('canvas');
            stamp.width = size;
            stamp.height = size;
            const sc = stamp.getContext('2d');
            const cx = size / 2;
            const grad = sc.createRadialGradient(cx, cx, 0, cx, cx, maxSize);
            grad.addColorStop(0, color);
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            sc.fillStyle = grad;
            sc.beginPath();
            sc.arc(cx, cx, maxSize, 0, Math.PI * 2);
            sc.fill();
            particleCache[key] = stamp;
            return stamp;
        }

        function drawParticles() {
            const colors = getSeasonColors(LEVELS[currentLevel - 1].season);

            particles.forEach(p => {
                const stamp = getParticleStamp(colors.particle, p.size);
                const half = stamp.width / 2;
                ctx.save();
                ctx.globalAlpha = p.opacity;
                ctx.translate(p.x, p.y);
                ctx.rotate(p.rotation);
                ctx.drawImage(stamp, -half, -half);
                ctx.restore();
            });
        }

        // ==================== SNAKE SKINS ====================
        const SNAKE_SKINS = {
            spring: {
                body:          '#6dd629',
                outline:       '#317a08',
                shine:         '#aeff50',
                pattern:       '#44aa0c',
                patternStyle:  'diamonds',
                tongue:        '#5599ff',
                eyeIris:       '#d4ff40',
                eyePupil:      '#163304',
                eyeRim:        '#246006',
            },
            summer: {
                body:          '#f0d840',
                outline:       '#907800',
                shine:         '#fff8a0',
                pattern:       'rgba(255,255,255,0.78)',
                patternStyle:  'dots',
                tongue:        '#ff88cc',
                eyeIris:       '#cc7800',
                eyePupil:      '#3a1c00',
                eyeRim:        '#704800',
            },
            autumn: {
                body:          '#f07830',
                outline:       '#7a2c08',
                shine:         '#ffb060',
                pattern:       '#fcd8a0',
                patternStyle:  'wavebands',
                tongue:        '#ff9988',
                eyeIris:       '#cc2200',
                eyePupil:      '#440000',
                eyeRim:        '#6a1000',
            },
            winter: {
                body:          '#d83030',
                outline:       '#700808',
                shine:         '#ff8080',
                pattern:       '#f0f0f0',
                patternBorder: '#500808',
                patternStyle:  'bands',
                tongue:        '#aaaaaa',
                eyeIris:       '#cc8888',
                eyePupil:      '#380808',
                eyeRim:        '#700808',
            },
            mystic: {
                body:          '#9955cc',
                outline:       '#3d1278',
                shine:         '#cc88ff',
                pattern:       '#6028a0',
                patternStyle:  'blotches',
                tongue:        '#cc88ff',
                eyeIris:       '#ee88ff',
                eyePupil:      '#200040',
                eyeRim:        '#4e1880',
            },
            void: {
                body:          '#1a2448',
                outline:       '#060c1c',
                shine:         '#4a6090',
                pattern:       '#4a9fd4',
                patternStyle:  'stripes',
                tongue:        '#c87020',
                eyeIris:       '#f0c000',
                eyePupil:      '#301800',
                eyeRim:        '#1a2030',
            },
        };

        // ==================== SNAKE RENDERING ====================
        function drawRealisticSnake() {
            if (snake.length === 0) return;

            const season = LEVELS[currentLevel - 1].season;
            const skin   = SNAKE_SKINS[season];

            const pts = snake.map(s => ({
                x: s.x * TILE_SIZE + TILE_SIZE / 2,
                y: s.y * TILE_SIZE + TILE_SIZE / 2,
            }));

            // Split at wrap-around boundaries
            const groups      = [];
            const groupOffset = [];   // global snake-index at start of each group
            let cur = [pts[0]], curOff = 0;
            for (let i = 1; i < pts.length; i++) {
                const dx = Math.abs(snake[i].x - snake[i - 1].x);
                const dy = Math.abs(snake[i].y - snake[i - 1].y);
                if (dx > GRID_SIZE / 2 || dy > GRID_SIZE / 2) {
                    groups.push(cur); groupOffset.push(curOff);
                    curOff = i; cur = [pts[i]];
                } else {
                    cur.push(pts[i]);
                }
            }
            groups.push(cur); groupOffset.push(curOff);

            const BW = TILE_SIZE * 0.82; // body stroke width

            // Build a smooth quadratic-bezier path through an array of {x,y} points
            function buildPath(seg) {
                ctx.beginPath();
                ctx.moveTo(seg[0].x, seg[0].y);
                for (let i = 1; i < seg.length; i++) {
                    const mx = (seg[i].x + seg[i - 1].x) / 2;
                    const my = (seg[i].y + seg[i - 1].y) / 2;
                    ctx.quadraticCurveTo(seg[i - 1].x, seg[i - 1].y, mx, my);
                }
                ctx.lineTo(seg[seg.length - 1].x, seg[seg.length - 1].y);
            }

            // Forward-direction angle at index i within a segment array
            function segAngle(seg, i) {
                if (i < seg.length - 1)
                    return Math.atan2(seg[i + 1].y - seg[i].y, seg[i + 1].x - seg[i].x);
                if (i > 0)
                    return Math.atan2(seg[i].y - seg[i - 1].y, seg[i].x - seg[i - 1].x);
                return 0;
            }

            // ---- PASS 1: drop shadow ----
            groups.forEach(seg => {
                if (seg.length < 2) return;
                ctx.save();
                ctx.shadowColor   = 'rgba(0,0,0,0.38)';
                ctx.shadowBlur    = 9;
                ctx.shadowOffsetX = 4;
                ctx.shadowOffsetY = 5;
                ctx.strokeStyle   = 'rgba(0,0,0,0.01)';
                ctx.lineWidth     = BW + 6;
                ctx.lineCap       = 'round';
                ctx.lineJoin      = 'round';
                buildPath(seg);
                ctx.stroke();
                ctx.restore();
            });

            // ---- PASS 2: dark outline ----
            groups.forEach(seg => {
                if (seg.length < 2) return;
                ctx.save();
                ctx.strokeStyle = skin.outline;
                ctx.lineWidth   = BW + 5;
                ctx.lineCap     = 'round';
                ctx.lineJoin    = 'round';
                buildPath(seg);
                ctx.stroke();
                ctx.restore();
            });

            // ---- PASS 3: body fill ----
            groups.forEach(seg => {
                if (seg.length < 2) return;
                ctx.save();
                ctx.strokeStyle = skin.body;
                ctx.lineWidth   = BW;
                ctx.lineCap     = 'round';
                ctx.lineJoin    = 'round';
                buildPath(seg);
                ctx.stroke();
                ctx.restore();
            });

            // ---- PASS 4: skin pattern ----
            if (skin.patternStyle === 'stripes') {
                // Two parallel longitudinal stripes (void/blue snake)
                [-BW * 0.22, BW * 0.22].forEach(off => {
                    groups.forEach((seg, gi) => {
                        const startI = (gi === 0) ? 1 : 0;
                        if (seg.length - startI < 2) return;
                        ctx.save();
                        ctx.strokeStyle = skin.pattern;
                        ctx.lineWidth   = BW * 0.17;
                        ctx.lineCap     = 'round';
                        ctx.lineJoin    = 'round';
                        ctx.beginPath();
                        let first = true;
                        for (let i = startI; i < seg.length; i++) {
                            const a    = segAngle(seg, i);
                            const perp = a + Math.PI / 2;
                            const ox   = seg[i].x + Math.cos(perp) * off;
                            const oy   = seg[i].y + Math.sin(perp) * off;
                            if (first) { ctx.moveTo(ox, oy); first = false; }
                            else        ctx.lineTo(ox, oy);
                        }
                        ctx.stroke();
                        ctx.restore();
                    });
                });
            } else {
                groups.forEach((seg, gi) => {
                    seg.forEach((pt, i) => {
                        if (gi === 0 && i === 0) return; // skip head position
                        const si    = groupOffset[gi] + i; // global snake index
                        const angle = segAngle(seg, i);

                        ctx.save();
                        ctx.translate(pt.x, pt.y);
                        ctx.rotate(angle);

                        switch (skin.patternStyle) {

                            case 'diamonds': {
                                // Rotated-square outline (green snake)
                                ctx.save();
                                ctx.rotate(Math.PI / 4);
                                ctx.strokeStyle = skin.pattern;
                                ctx.lineWidth   = 1.8;
                                ctx.globalAlpha = 0.72;
                                const dr = BW * 0.36;
                                ctx.strokeRect(-dr, -dr, dr * 2, dr * 2);
                                ctx.restore();
                                break;
                            }

                            case 'dots': {
                                // Staggered white dots (yellow snake)
                                const dotR   = BW * 0.10;
                                const dotOff = (si % 2 === 0) ? -BW * 0.21 : BW * 0.21;
                                ctx.fillStyle   = skin.pattern;
                                ctx.globalAlpha = 0.80;
                                ctx.beginPath();
                                ctx.arc(0, dotOff, dotR, 0, Math.PI * 2);
                                ctx.fill();
                                if (si % 3 === 0) {
                                    ctx.globalAlpha = 0.55;
                                    ctx.beginPath();
                                    ctx.arc(0, -dotOff * 0.5, dotR * 0.7, 0, Math.PI * 2);
                                    ctx.fill();
                                }
                                break;
                            }

                            case 'wavebands': {
                                // Curved perpendicular arcs (autumn/orange snake) — every 2nd segment
                                if (si % 2 !== 0) break;
                                ctx.strokeStyle = skin.pattern;
                                ctx.lineWidth   = BW * 0.48;
                                ctx.lineCap     = 'round';
                                ctx.globalAlpha = 0.60;
                                ctx.beginPath();
                                ctx.moveTo(-BW * 0.14, -BW * 0.44);
                                ctx.quadraticCurveTo(BW * 0.34, 0, -BW * 0.14, BW * 0.44);
                                ctx.stroke();
                                break;
                            }

                            case 'bands': {
                                // Wide perpendicular white bands (winter/red snake) — every 2nd segment
                                if (si % 2 !== 0) break;
                                const bw = BW * 0.55;
                                const bh = BW * 0.43;
                                ctx.fillStyle   = skin.pattern;
                                ctx.globalAlpha = 0.85;
                                ctx.fillRect(-bw / 2, -bh, bw, bh * 2);
                                if (skin.patternBorder) {
                                    ctx.strokeStyle = skin.patternBorder;
                                    ctx.lineWidth   = 1.4;
                                    ctx.globalAlpha = 0.50;
                                    ctx.strokeRect(-bw / 2, -bh, bw, bh * 2);
                                }
                                break;
                            }

                            case 'blotches': {
                                // Irregular dark ovals (mystic/purple snake) — every 2nd segment
                                if (si % 2 !== 0) break;
                                ctx.fillStyle   = skin.pattern;
                                ctx.globalAlpha = 0.65;
                                ctx.beginPath();
                                ctx.ellipse(0, 0, BW * 0.46, BW * 0.28, 0.35, 0, Math.PI * 2);
                                ctx.fill();
                                break;
                            }
                        }

                        ctx.restore();
                    });
                });
            }

            // ---- PASS 5: highlight sheen ----
            groups.forEach(seg => {
                if (seg.length < 2) return;
                ctx.save();
                ctx.strokeStyle = skin.shine;
                ctx.globalAlpha = 0.20;
                ctx.lineWidth   = BW * 0.28;
                ctx.lineCap     = 'round';
                ctx.lineJoin    = 'round';
                buildPath(seg);
                ctx.stroke();
                ctx.restore();
            });

            // ---- PASS 6: pointed tail tip ----
            if (pts.length >= 2) {
                const lastSeg  = groups[groups.length - 1];
                const tail     = lastSeg[lastSeg.length - 1];
                const tailAngl = segAngle(lastSeg, lastSeg.length - 1);
                const tipLen   = BW * 0.9;
                ctx.save();
                ctx.translate(tail.x, tail.y);
                ctx.rotate(tailAngl);
                ctx.fillStyle   = skin.body;
                ctx.strokeStyle = skin.outline;
                ctx.lineWidth   = 1.8;
                ctx.lineJoin    = 'round';
                ctx.beginPath();
                ctx.moveTo(0,  -BW * 0.38);
                ctx.quadraticCurveTo(tipLen * 0.55, -BW * 0.12, tipLen, 0);
                ctx.quadraticCurveTo(tipLen * 0.55,  BW * 0.12, 0,  BW * 0.38);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                ctx.restore();
            }

            // ==================== CARTOON HEAD ====================
            const head = pts[0];
            let headAngle;
            if (pts.length > 1) {
                const dxW = Math.abs(snake[0].x - snake[1].x);
                const dyW = Math.abs(snake[0].y - snake[1].y);
                headAngle = (dxW <= GRID_SIZE / 2 && dyW <= GRID_SIZE / 2)
                    ? Math.atan2(head.y - pts[1].y, head.x - pts[1].x)
                    : Math.atan2(direction.y, direction.x);
            } else {
                headAngle = Math.atan2(direction.y, direction.x);
            }

            ctx.save();
            ctx.translate(head.x, head.y);
            ctx.rotate(headAngle);

            const HR  = TILE_SIZE * 0.50;   // head "radius"
            const HRx = HR * 1.07;          // forward semi-axis
            const HRy = HR * 0.94;          // lateral semi-axis

            // Head drop shadow
            ctx.save();
            ctx.shadowColor   = 'rgba(0,0,0,0.42)';
            ctx.shadowBlur    = 10;
            ctx.shadowOffsetX = 4;
            ctx.shadowOffsetY = 5;
            ctx.fillStyle     = 'rgba(0,0,0,0.01)';
            ctx.beginPath();
            ctx.ellipse(HR * 0.06, 0, HRx + 3, HRy + 3, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // Head outline blob
            ctx.fillStyle = skin.outline;
            ctx.beginPath();
            ctx.ellipse(HR * 0.06, 0, HRx + 3, HRy + 3, 0, 0, Math.PI * 2);
            ctx.fill();

            // Head fill
            ctx.fillStyle = skin.body;
            ctx.beginPath();
            ctx.ellipse(HR * 0.06, 0, HRx, HRy, 0, 0, Math.PI * 2);
            ctx.fill();

            // Head highlight sheen
            ctx.save();
            ctx.fillStyle   = skin.shine;
            ctx.globalAlpha = 0.24;
            ctx.beginPath();
            ctx.ellipse(-HR * 0.10, -HRy * 0.30, HRx * 0.48, HRy * 0.33, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            // Eyes (positioned on sides, slightly forward of centre)
            const eyeX    = HR * 0.05;
            const eyeDist = HRy * 0.60;
            const eyeR    = HR * 0.28;
            [-1, 1].forEach(side => {
                const ex = eyeX;
                const ey = side * eyeDist;

                // Socket rim
                ctx.fillStyle = skin.eyeRim;
                ctx.beginPath();
                ctx.arc(ex, ey, eyeR + 2.5, 0, Math.PI * 2);
                ctx.fill();

                // Iris
                ctx.fillStyle = skin.eyeIris;
                ctx.beginPath();
                ctx.arc(ex, ey, eyeR, 0, Math.PI * 2);
                ctx.fill();

                // Pupil
                ctx.fillStyle = skin.eyePupil;
                ctx.beginPath();
                ctx.arc(ex + eyeR * 0.12, ey, eyeR * 0.50, 0, Math.PI * 2);
                ctx.fill();

                // Catchlight
                ctx.fillStyle = 'rgba(255,255,255,0.90)';
                ctx.beginPath();
                ctx.arc(ex - eyeR * 0.22, ey - eyeR * 0.28, eyeR * 0.26, 0, Math.PI * 2);
                ctx.fill();
            });

            // Nostrils — two small dark ellipses at the snout tip
            const nX  = HRx * 0.87;
            const nDY = HRy * 0.24;
            ctx.save();
            ctx.fillStyle   = skin.outline;
            ctx.globalAlpha = 0.82;
            [-1, 1].forEach(side => {
                ctx.beginPath();
                ctx.ellipse(nX, side * nDY, HR * 0.086, HR * 0.065, 0.2 * side, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.restore();

            // Tongue — always flickers; extends toward nearby food
            const foodDist   = (food.x !== undefined)
                ? Math.abs(snake[0].x - food.x) + Math.abs(snake[0].y - food.y)
                : 999;
            const tongueOut  = jawAngle > 0.06 || foodDist <= 5 || Math.sin(animationFrame * 0.14) > 0.55;
            if (tongueOut) {
                const flick   = Math.sin(animationFrame * 0.52) * 3.5;
                const baseLen = 9 + Math.abs(Math.sin(animationFrame * 0.31)) * 9;
                const forkLen = 6;
                const tStart  = HRx + 2;
                ctx.save();
                ctx.globalAlpha = 0.92;
                ctx.strokeStyle = skin.tongue;
                ctx.lineCap     = 'round';
                ctx.lineWidth   = 2.1;
                ctx.beginPath();
                ctx.moveTo(tStart, 0);
                ctx.lineTo(tStart + baseLen, flick * 0.18);
                ctx.stroke();
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(tStart + baseLen, flick * 0.18);
                ctx.lineTo(tStart + baseLen + forkLen, -5.5 + flick);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(tStart + baseLen, flick * 0.18);
                ctx.lineTo(tStart + baseLen + forkLen,  5.5 + flick);
                ctx.stroke();
                ctx.restore();
            }

            ctx.restore(); // end head transform
        }

        // ==================== FOOD RENDERING ====================
        const foodSpriteCache = {};
        function getFoodSprite(type) {
            if (foodSpriteCache[type]) return foodSpriteCache[type];
            const EMOJI_MAP = { APPLE: '🍎', MOUSE: '🐭', RABBIT: '🐰' };
            const SIZE = Math.round(TILE_SIZE * 1.4);
            const PAD  = 8;
            const w    = SIZE + PAD * 2;
            const oc   = document.createElement('canvas');
            oc.width = w; oc.height = w;
            const sc   = oc.getContext('2d');
            sc.font = `${SIZE}px serif`;
            sc.textAlign = 'center';
            sc.textBaseline = 'middle';
            sc.fillText(EMOJI_MAP[type], w / 2, w / 2);
            foodSpriteCache[type] = oc;
            return oc;
        }

        function drawFoodGlow(fx, fy, r, g, b, baseRadius) {
            // Breathing glow ring around food
            const pulse = 0.5 + 0.5 * Math.sin(animationFrame * 0.12);
            const glowRadius = baseRadius + 6 + pulse * 8;
            const innerAlpha = 0.35 + pulse * 0.2;
            const glowGrad = ctx.createRadialGradient(fx, fy, baseRadius * 0.6, fx, fy, glowRadius);
            glowGrad.addColorStop(0, `rgba(${r},${g},${b},${innerAlpha.toFixed(2)})`);
            glowGrad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = glowGrad;
            ctx.beginPath();
            ctx.arc(fx, fy, glowRadius, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawRealisticFood() {
            if (food.x === undefined || food.y === undefined) return;

            const fx     = food.x * TILE_SIZE + TILE_SIZE / 2;
            const fy     = food.y * TILE_SIZE + TILE_SIZE / 2;
            const sprite = getFoodSprite(food.type);
            const sw     = sprite.width;

            if (food.type === 'RABBIT') {
                drawFoodGlow(fx, fy, 240, 240, 200, 16);
                const hopT       = Math.abs(Math.sin(animationFrame * 0.15));
                const hop        = hopT * 15;
                const ry         = fy - hop;
                const shadowScaleX = 1 - hopT * 0.55;
                const peakScale  = 1 + hopT * 0.12;

                // Dynamic shadow — shrinks as rabbit rises
                ctx.save();
                ctx.fillStyle = 'rgba(0,0,0,0.35)';
                ctx.beginPath();
                ctx.ellipse(fx, fy + 3, 16 * shadowScaleX, 6 * shadowScaleX, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                // Emoji sprite with scale pulse at hop peak
                ctx.save();
                ctx.translate(fx, ry);
                ctx.scale(peakScale, peakScale);
                ctx.drawImage(sprite, -sw / 2, -sw / 2, sw, sw);
                ctx.restore();

            } else if (food.type === 'MOUSE') {
                drawFoodGlow(fx, fy, 160, 160, 160, 12);
                // Lateral quiver simulates nervous twitching
                const quiver = Math.sin(animationFrame * 0.9) * 0.8;

                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.ellipse(fx + quiver, fy + 3, 14, 5, 0, 0, Math.PI * 2);
                ctx.fill();

                // Emoji sprite with quiver offset
                ctx.save();
                ctx.translate(fx + quiver, fy);
                ctx.drawImage(sprite, -sw / 2, -sw / 2, sw, sw);
                ctx.restore();

            } else {
                // Apple — gentle bob + subtle scale pulse
                drawFoodGlow(fx, fy, 229, 57, 53, 13);
                const bob   = Math.sin(animationFrame * 0.07) * 2;
                const pulse = 1 + Math.sin(animationFrame * 0.09) * 0.04;

                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.ellipse(fx, fy + 3, 11, 4, 0, 0, Math.PI * 2);
                ctx.fill();

                // Emoji sprite with bob and scale pulse
                ctx.save();
                ctx.translate(fx, fy + bob);
                ctx.scale(pulse, pulse);
                ctx.drawImage(sprite, -sw / 2, -sw / 2, sw, sw);
                ctx.restore();
            }
        }

        // ==================== GAME LOGIC ====================
        function spawnFood() {
            // Clear probability-based food selection
            // APPLE: 60%, MOUSE: 30%, RABBIT: 10%
            const rand = Math.random();
            let type;

            if (rand < FOOD_TYPES.RABBIT.probability) {
                // 0 to 0.1 (10%)
                type = 'RABBIT';
            } else if (rand < FOOD_TYPES.RABBIT.probability + FOOD_TYPES.MOUSE.probability) {
                // 0.1 to 0.4 (30%)
                type = 'MOUSE';
            } else {
                // 0.4 to 1.0 (60%)
                type = 'APPLE';
            }

            let x, y;
            let attempts = 0;

            do {
                x = Math.floor(Math.random() * GRID_SIZE);
                y = Math.floor(Math.random() * GRID_SIZE);
                attempts++;

                if (attempts >= MAX_FOOD_SPAWN_ATTEMPTS) {
                    break;
                }
            } while (snake.some(s => s.x === x && s.y === y));

            food = {
                x: x,
                y: y,
                type: type,
                points: FOOD_TYPES[type].points
            };
        }

        function checkLevelUp() {
            if (score >= LEVELS[currentLevel - 1].pointsNeeded && currentLevel < LEVELS.length) {
                currentLevel++;
                updateLevel();
                generateVegetation();
                initParticles();
                // Trigger expanding ring burst at screen centre
                levelUpBurst = { x: CANVAS_SIZE / 2, y: CANVAS_SIZE / 2, radius: 30, alpha: 1 };
                // CSS flash on the level indicator
                levelEl.classList.remove('level-flash');
                void levelEl.offsetWidth; // force reflow to restart animation
                levelEl.classList.add('level-flash');
                announce('Level ' + currentLevel + '!');
            }
        }

        function updateScore() {
            scoreEl.textContent = score;
            // Score pop animation
            scoreEl.classList.remove('score-pop');
            void scoreEl.offsetWidth; // force reflow
            scoreEl.classList.add('score-pop');
            if (score > highScore) {
                highScore = score;
                saveHighScore(highScore);
                highScoreEl.textContent = highScore;
            }
        }

        function updateLevel() {
            levelEl.textContent = currentLevel;
        }

        function gameOver() {
            gameState = 'gameover';
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            deathFlashAlpha = 0.65; // trigger red flash
            finalScoreEl.textContent = score;
            finalLevelEl.textContent = currentLevel;
            // Show game over screen after the flash draws one frame
            requestAnimationFrame(() => {
                draw();
                setTimeout(() => {
                    gameOverScreen.style.display = 'block';
                    startIdleAnimation();
                }, 400);
            });
            announce('Game over. Final score: ' + score);
        }

        // ==================== ERROR DISPLAY ====================
        function showErrorOverlay() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.88)';
            ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            ctx.shadowBlur = 0;
            ctx.textAlign = 'center';
            ctx.fillStyle = '#ff4444';
            ctx.font = 'bold 26px Segoe UI, sans-serif';
            ctx.fillText('Something went wrong', CANVAS_SIZE / 2, CANVAS_SIZE / 2 - 24);
            ctx.fillStyle = '#cccccc';
            ctx.font = '16px Segoe UI, sans-serif';
            ctx.fillText('Please refresh the page to restart.', CANVAS_SIZE / 2, CANVAS_SIZE / 2 + 18);
        }

        // ==================== GAME LOOP (requestAnimationFrame) ====================
        function gameLoop(timestamp) {
            if (gameState !== 'playing') return;

            try {
                if (!lastUpdateTime) {
                    lastUpdateTime = timestamp;
                }

                const deltaTime = timestamp - lastUpdateTime;
                lastUpdateTime = timestamp;
                accumulatedTime += deltaTime;

                const currentSpeed = LEVELS[currentLevel - 1].speed;

                while (accumulatedTime >= currentSpeed) {
                    update();
                    accumulatedTime -= currentSpeed;

                    if (gameState !== 'playing') {
                        return;
                    }
                }

                draw();
                animationId = requestAnimationFrame(gameLoop);
            } catch (err) {
                gameState = 'gameover';
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
                showErrorOverlay();
                announce('An error occurred. Please refresh the page.');
            }
        }

        function updateJawAngle() {
            if (food.x === undefined || gameState !== 'playing') {
                jawAngle = Math.max(0, jawAngle - 0.06);
                return;
            }
            const dist = Math.abs(snake[0].x - food.x) + Math.abs(snake[0].y - food.y);
            const targetAngle = dist <= JAW_OPEN_DISTANCE
                ? MAX_JAW_ANGLE * (1 - dist / (JAW_OPEN_DISTANCE + 1))
                : 0;
            jawAngle += (targetAngle - jawAngle) * 0.22;
            if (jawAngle < 0.008) jawAngle = 0;
        }

        function update() {
            direction.x = nextDirection.x;
            direction.y = nextDirection.y;
            updateJawAngle();

            let headX = snake[0].x + direction.x;
            let headY = snake[0].y + direction.y;

            // Wrap around
            if (headX < 0) headX = GRID_SIZE - 1;
            if (headX >= GRID_SIZE) headX = 0;
            if (headY < 0) headY = GRID_SIZE - 1;
            if (headY >= GRID_SIZE) headY = 0;

            // Self collision
            if (snake.some(s => s.x === headX && s.y === headY)) {
                gameOver();
                return;
            }

            snake.unshift({ x: headX, y: headY });

            // Failsafe: ensure food exists
            if (food.x === undefined || food.y === undefined) {
                spawnFood();
            }

            if (headX === food.x && headY === food.y) {
                score += food.points;
                updateScore();
                spawnFood();
                checkLevelUp();
            } else {
                snake.pop();
            }

            animationFrame++;
            updateParticles();
        }

        function drawLevelUpBurst() {
            if (!levelUpBurst) return;
            const b = levelUpBurst;
            ctx.save();
            ctx.globalAlpha = b.alpha;
            ctx.strokeStyle = '#7CFC00';
            ctx.lineWidth = 4;
            ctx.shadowColor = '#7CFC00';
            ctx.shadowBlur = 20;
            ctx.beginPath();
            ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();

            b.radius += 10;
            b.alpha -= 0.045;
            if (b.alpha <= 0) levelUpBurst = null;
        }

        function drawDeathFlash() {
            if (deathFlashAlpha <= 0) return;
            ctx.save();
            ctx.globalAlpha = deathFlashAlpha;
            ctx.fillStyle = '#ff1111';
            ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            ctx.restore();
            deathFlashAlpha -= 0.06;
            if (deathFlashAlpha < 0) deathFlashAlpha = 0;
        }

        function draw() {
            drawBackground();
            drawParticles();
            drawRealisticSnake();
            drawRealisticFood();
            drawLevelUpBurst();
            drawDeathFlash();

            if (gameState === 'paused') {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
                ctx.fillStyle = '#7CFC00';
                ctx.font = 'bold 50px Segoe UI';
                ctx.textAlign = 'center';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                ctx.shadowBlur = 15;
                ctx.fillText('PAUSED', CANVAS_SIZE / 2, CANVAS_SIZE / 2);
                ctx.shadowBlur = 0;
            }
        }

        // ==================== IDLE ANIMATION ====================
        function startIdleAnimation() {
            if (idleAnimationId) return;

            let lastIdleTime = 0;

            function idleLoop(timestamp) {
                if (gameState === 'playing') {
                    idleAnimationId = null;
                    return;
                }

                if (timestamp - lastIdleTime >= IDLE_FRAME_INTERVAL) {
                    animationFrame++;
                    updateParticles();
                    draw();
                    lastIdleTime = timestamp;
                }

                idleAnimationId = requestAnimationFrame(idleLoop);
            }

            idleAnimationId = requestAnimationFrame(idleLoop);
        }

        function stopIdleAnimation() {
            if (idleAnimationId) {
                cancelAnimationFrame(idleAnimationId);
                idleAnimationId = null;
            }
        }

        // ==================== GAME CONTROLS ====================
        function startGame() {
            snake = [
                { x: 12, y: 12 },
                { x: 11, y: 12 },
                { x: 10, y: 12 }
            ];

            direction = { x: 1, y: 0 };
            nextDirection = { x: 1, y: 0 };
            score = 0;
            currentLevel = 1;
            gameState = 'playing';
            animationFrame = 0;
            lastUpdateTime = 0;
            accumulatedTime = 0;
            levelUpBurst = null;
            deathFlashAlpha = 0;
            jawAngle = 0;

            startScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';

            updateScore();
            updateLevel();
            generateVegetation();
            initParticles();
            spawnFood();

            stopIdleAnimation();

            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            animationId = requestAnimationFrame(gameLoop);
            announce('Game started');
        }

        function togglePause() {
            if (gameState === 'playing') {
                gameState = 'paused';
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
                draw();
                startIdleAnimation();
                announce('Game paused');
            } else if (gameState === 'paused') {
                gameState = 'playing';
                stopIdleAnimation();
                lastUpdateTime = 0;
                accumulatedTime = 0;
                animationId = requestAnimationFrame(gameLoop);
                announce('Game resumed');
            }
        }

        function resetGame() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            stopIdleAnimation();

            gameState = 'start';
            currentLevel = 1;
            startScreen.style.display = 'block';
            gameOverScreen.style.display = 'none';
            generateVegetation();
            initParticles();
            startIdleAnimation();
            announce('Game reset');
        }

        // ==================== EVENT HANDLERS ====================
        function handleKeydown(e) {
            if (e.code === 'Space') {
                e.preventDefault();
                if (gameState === 'start' || gameState === 'gameover') {
                    startGame();
                } else if (gameState === 'playing' || gameState === 'paused') {
                    togglePause();
                }
                return;
            }

            if (gameState !== 'playing') return;

            switch (e.key) {
                case 'ArrowUp':
                    e.preventDefault();
                    if (direction.y === 0) nextDirection = { x: 0, y: -1 };
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    if (direction.y === 0) nextDirection = { x: 0, y: 1 };
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    if (direction.x === 0) nextDirection = { x: -1, y: 0 };
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    if (direction.x === 0) nextDirection = { x: 1, y: 0 };
                    break;
            }
        }

        function handleTouchStart(e) {
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
        }

        function handleTouchEnd(e) {
            if (!touchStartX || !touchStartY) return;

            const touch = e.changedTouches[0];
            const deltaX = touch.clientX - touchStartX;
            const deltaY = touch.clientY - touchStartY;

            touchStartX = 0;
            touchStartY = 0;

            // Check if it's a tap (not a swipe)
            if (Math.abs(deltaX) < SWIPE_THRESHOLD && Math.abs(deltaY) < SWIPE_THRESHOLD) {
                if (gameState === 'start' || gameState === 'gameover') {
                    startGame();
                }
                return;
            }

            if (gameState !== 'playing') return;

            // Determine swipe direction
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                // Horizontal swipe
                if (deltaX > SWIPE_THRESHOLD && direction.x === 0) {
                    nextDirection = { x: 1, y: 0 };
                } else if (deltaX < -SWIPE_THRESHOLD && direction.x === 0) {
                    nextDirection = { x: -1, y: 0 };
                }
            } else {
                // Vertical swipe
                if (deltaY > SWIPE_THRESHOLD && direction.y === 0) {
                    nextDirection = { x: 0, y: 1 };
                } else if (deltaY < -SWIPE_THRESHOLD && direction.y === 0) {
                    nextDirection = { x: 0, y: -1 };
                }
            }
        }

        // Attach event listeners
        document.addEventListener('keydown', handleKeydown);
        canvas.addEventListener('touchstart', handleTouchStart, { passive: true });
        canvas.addEventListener('touchend', handleTouchEnd, { passive: true });

        startBtn.addEventListener('click', startGame);
        pauseBtn.addEventListener('click', togglePause);
        restartBtn.addEventListener('click', resetGame);

        // ==================== INITIAL SETUP ====================
        generateVegetation();
        initParticles();
        draw();
        startIdleAnimation();

    })();
    </script>
</body>
</html>
