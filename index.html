<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Serpent - Modern Snake Game</title>
    <meta name="description" content="Serpent – a modern, realistic Snake game with seasonal themes, animated food, and 10 levels of increasing challenge.">
    <meta property="og:title" content="Serpent – Modern Snake Game">
    <meta property="og:description" content="Play Serpent, a beautifully rendered Snake game with seasonal themes, animated food types, and 10 challenging levels.">
    <meta property="og:type" content="website">
    <meta name="theme-color" content="#0f2027">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 10px;
            box-sizing: border-box;
        }

        .game-container {
            background: linear-gradient(145deg, #1a1a1a, #2d2d2d);
            padding: 30px;
            border-radius: 25px;
            box-shadow:
                0 40px 80px rgba(0, 0, 0, 0.9),
                inset 0 2px 0 rgba(255, 255, 255, 0.1);
            border: 4px solid #444;
            max-width: 820px;
            width: 100%;
        }

        .game-wrapper {
            background: linear-gradient(135deg, #1e3c28 0%, #2d5a3d 100%);
            border: 12px solid #0a0a0a;
            border-radius: 15px;
            padding: 10px;
            box-shadow:
                inset 0 0 50px rgba(0, 0, 0, 0.6),
                0 10px 30px rgba(0, 0, 0, 0.7);
        }

        .info-bar {
            display: flex;
            justify-content: space-between;
            padding: 15px 20px;
            background: linear-gradient(180deg, rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.5));
            margin-bottom: 10px;
            font-weight: 600;
            color: #fff;
            font-size: 16px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
        }

        .info-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .label {
            font-size: 11px;
            opacity: 0.7;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .value {
            font-size: 20px;
            font-weight: bold;
            color: #7CFC00;
            text-shadow: 0 0 10px rgba(124, 252, 0, 0.5);
        }

        canvas {
            display: block;
            border-radius: 10px;
            box-shadow:
                inset 0 0 30px rgba(0, 0, 0, 0.3),
                0 10px 25px rgba(0, 0, 0, 0.6);
            touch-action: none;
        }

        .controls {
            margin-top: 30px;
            text-align: center;
            color: #fff;
        }

        .controls h3 {
            margin-bottom: 15px;
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.8);
            font-size: 22px;
            letter-spacing: 2px;
        }

        .controls p {
            margin: 8px 0;
            font-size: 14px;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.6);
            opacity: 0.9;
        }

        .button-container {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }

        button {
            padding: 16px 32px;
            background: linear-gradient(135deg, #7CFC00, #32CD32);
            border: none;
            border-radius: 12px;
            color: #000;
            font-family: 'Segoe UI', sans-serif;
            font-weight: bold;
            cursor: pointer;
            font-size: 15px;
            transition: all 0.3s ease;
            box-shadow:
                0 8px 16px rgba(124, 252, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        button:hover {
            background: linear-gradient(135deg, #90FF10, #40E040);
            transform: translateY(-4px) scale(1.05);
            box-shadow:
                0 12px 24px rgba(124, 252, 0, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.4);
        }

        button:active {
            transform: translateY(-2px) scale(1.02);
        }

        button:focus {
            outline: 3px solid #7CFC00;
            outline-offset: 2px;
        }

        .overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(20, 40, 20, 0.95));
            padding: 40px 50px;
            border-radius: 20px;
            text-align: center;
            color: #fff;
            display: none;
            border: 4px solid #7CFC00;
            box-shadow:
                0 20px 60px rgba(0, 0, 0, 0.9),
                inset 0 2px 0 rgba(124, 252, 0, 0.2);
            backdrop-filter: blur(10px);
        }

        .overlay h2 {
            margin-bottom: 20px;
            font-size: 42px;
            text-shadow:
                2px 2px 4px rgba(0, 0, 0, 0.8),
                0 0 20px rgba(124, 252, 0, 0.6);
            color: #7CFC00;
        }

        .overlay p {
            margin: 15px 0;
            font-size: 18px;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.8);
        }

        .legend {
            margin-top: 25px;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 12px;
            font-size: 14px;
            border: 2px solid rgba(124, 252, 0, 0.3);
        }

        .legend-item {
            margin: 8px 0;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .pulsing {
            animation: pulse 2s infinite;
        }

        @keyframes scorePop {
            0%   { transform: scale(1);    color: #7CFC00; }
            40%  { transform: scale(1.45); color: #ffffff; text-shadow: 0 0 18px #fff, 0 0 8px #7CFC00; }
            100% { transform: scale(1);    color: #7CFC00; }
        }

        .score-pop {
            animation: scorePop 0.35s ease-out;
        }

        @keyframes levelFlash {
            0%   { background: rgba(124,252,0,0.18); }
            100% { background: transparent; }
        }

        .level-flash {
            animation: levelFlash 0.6s ease-out;
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* ---- Mobile responsive scaling ---- */
        @media (max-width: 780px) {
            body {
                align-items: flex-start;
                padding: 10px;
            }
            .game-container {
                padding: 12px;
                border-radius: 15px;
            }
            .game-wrapper {
                border-width: 6px;
                padding: 4px;
            }
            canvas {
                width: 100% !important;
                height: auto !important;
            }
            .info-bar {
                padding: 8px 12px;
                font-size: 13px;
            }
            .value {
                font-size: 16px;
            }
            .button-container {
                flex-wrap: wrap;
            }
            button {
                padding: 12px 18px;
                font-size: 13px;
            }
            .overlay {
                padding: 24px 28px;
                width: 90%;
            }
            .overlay h2 {
                font-size: 30px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container" role="main" aria-label="Snake Game">
        <div class="game-wrapper">
            <div class="info-bar" role="status" aria-live="polite">
                <div class="info-item">
                    <span class="label" id="score-label">Score</span>
                    <span class="value" id="score" aria-labelledby="score-label">0</span>
                </div>
                <div class="info-item">
                    <span class="label" id="level-label">Level</span>
                    <span class="value" id="level" aria-labelledby="level-label">1</span>
                </div>
                <div class="info-item">
                    <span class="label" id="highscore-label">High Score</span>
                    <span class="value" id="highScore" aria-labelledby="highscore-label">0</span>
                </div>
            </div>
            <canvas id="gameCanvas" width="700" height="700" aria-label="Game canvas - use arrow keys to control the snake" tabindex="0"></canvas>

            <div class="overlay" id="startScreen" role="dialog" aria-labelledby="start-title">
                <h2 id="start-title">SERPENT</h2>
                <p style="font-size: 16px; opacity: 0.8;">Modern Realistic Snake Game</p>
                <p style="margin-top: 25px;">Press SPACE or tap START to begin</p>
                <div class="legend">
                    <div class="legend-item">Rabbit: 50 points (Rare, Animated)</div>
                    <div class="legend-item">Mouse: 20 points (Common)</div>
                    <div class="legend-item">Apple: 10 points (Common)</div>
                </div>
            </div>

            <div class="overlay" id="gameOverScreen" role="dialog" aria-labelledby="gameover-title">
                <h2 id="gameover-title">GAME OVER</h2>
                <p>Final Score: <span id="finalScore">0</span></p>
                <p>Level Reached: <span id="finalLevel">1</span></p>
                <p style="margin-top: 25px;" class="pulsing">Press SPACE or tap RESTART</p>
            </div>
        </div>

        <div class="controls">
            <h3>CONTROLS</h3>
            <p>Arrow Keys / Swipe - Move Snake</p>
            <p>SPACE - Start / Pause / Resume</p>
            <div class="button-container">
                <button id="startBtn" aria-label="Start game">START</button>
                <button id="pauseBtn" aria-label="Pause game">PAUSE</button>
                <button id="restartBtn" aria-label="Restart game">RESTART</button>
            </div>
        </div>
        <div class="sr-only" id="game-announcer" aria-live="assertive"></div>
    </div>

    <script>
    'use strict';

    (function() {
        // ==================== CONSTANTS ====================
        const CANVAS_SIZE = 700;
        const GRID_SIZE = 25;
        const TILE_SIZE = CANVAS_SIZE / GRID_SIZE;
        const GRASS_COUNT = 400;
        const SHRUB_COUNT = 25;
        const SHRUB_EDGE_MARGIN = 80;
        const PARTICLE_COUNT = 40;
        const LIGHT_PATCH_COUNT = 5;
        const MAX_FOOD_SPAWN_ATTEMPTS = 100;
        const IDLE_FRAME_INTERVAL = 50;
        const MAX_JAW_ANGLE = 0.55;   // radians (~31°) — how wide the jaw opens
        const JAW_OPEN_DISTANCE = 4;  // grid tiles within which jaw starts to open

        const FOOD_TYPES = {
            APPLE: { points: 10, probability: 0.6 },
            MOUSE: { points: 20, probability: 0.3 },
            RABBIT: { points: 50, probability: 0.1 }
        };

        const LEVELS = [
            { level: 1, speed: 140, pointsNeeded: 100, season: 'spring' },
            { level: 2, speed: 125, pointsNeeded: 250, season: 'summer' },
            { level: 3, speed: 110, pointsNeeded: 400, season: 'autumn' },
            { level: 4, speed: 95, pointsNeeded: 600, season: 'winter' },
            { level: 5, speed: 80, pointsNeeded: 850, season: 'spring' },
            { level: 6, speed: 70, pointsNeeded: 1150, season: 'summer' },
            { level: 7, speed: 60, pointsNeeded: 1500, season: 'autumn' },
            { level: 8, speed: 50, pointsNeeded: 1900, season: 'winter' },
            { level: 9, speed: 40, pointsNeeded: 2400, season: 'mystic' },
            { level: 10, speed: 30, pointsNeeded: Infinity, season: 'void' }
        ];

        const SEASONS = {
            spring: {
                ground: ['#7cb342', '#8bc34a', '#9ccc65'],
                grass: '#4caf50',
                accent: '#66bb6a',
                particle: '#ffb6c1'
            },
            summer: {
                ground: ['#9ccc65', '#aed581', '#c5e1a5'],
                grass: '#7cb342',
                accent: '#8bc34a',
                particle: '#ffd54f'
            },
            autumn: {
                ground: ['#a1887f', '#bcaaa4', '#d7ccc8'],
                grass: '#8d6e63',
                accent: '#a1887f',
                particle: '#ff8a65'
            },
            winter: {
                ground: ['#cfd8dc', '#eceff1', '#ffffff'],
                grass: '#b0bec5',
                accent: '#cfd8dc',
                particle: '#e1f5fe'
            },
            mystic: {
                ground: ['#4db6ac', '#26a69a', '#009688'],
                grass: '#00897b',
                accent: '#26a69a',
                particle: '#00e5ff'
            },
            void: {
                ground: ['#424242', '#616161', '#757575'],
                grass: '#212121',
                accent: '#424242',
                particle: '#9e9e9e'
            }
        };

        // ==================== DOM ELEMENTS ====================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Canvas context fallback check
        if (!ctx) {
            document.body.innerHTML = '<p style="color: white; text-align: center; margin-top: 50px;">Your browser does not support HTML5 Canvas. Please use a modern browser.</p>';
            return;
        }

        // Handle GPU/context loss (e.g. low memory, tab switching on mobile)
        canvas.addEventListener('contextlost', function(e) {
            e.preventDefault();
            if (animationId) { cancelAnimationFrame(animationId); animationId = null; }
            if (idleAnimationId) { cancelAnimationFrame(idleAnimationId); idleAnimationId = null; }
            announce('Display connection lost. Please wait...');
        }, false);

        canvas.addEventListener('contextrestored', function() {
            preRenderBackground();
            draw();
            if (gameState !== 'playing') startIdleAnimation();
            announce('Display restored.');
        }, false);

        const scoreEl = document.getElementById('score');
        const levelEl = document.getElementById('level');
        const highScoreEl = document.getElementById('highScore');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const finalScoreEl = document.getElementById('finalScore');
        const finalLevelEl = document.getElementById('finalLevel');
        const startBtn = document.getElementById('startBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const restartBtn = document.getElementById('restartBtn');
        const announcer = document.getElementById('game-announcer');

        // Offscreen canvas for pre-rendered background
        const bgCanvas = document.createElement('canvas');
        bgCanvas.width = CANVAS_SIZE;
        bgCanvas.height = CANVAS_SIZE;
        const bgCtx = bgCanvas.getContext('2d');

        // ==================== VISUAL EFFECT STATE ====================
        let levelUpBurst = null;   // { x, y, radius, maxRadius, alpha }
        let deathFlashAlpha = 0;   // 0–1, drives the red overlay on death

        // ==================== GAME STATE ====================
        let snake = [];
        let direction = { x: 1, y: 0 };
        let nextDirection = { x: 1, y: 0 };
        let food = {};
        let score = 0;
        function loadHighScore() {
            try {
                return parseInt(localStorage.getItem('serpentHighScore'), 10) || 0;
            } catch (e) {
                return 0;
            }
        }
        function saveHighScore(val) {
            try {
                localStorage.setItem('serpentHighScore', val);
            } catch (e) { /* quota exceeded or private/incognito mode */ }
        }
        let highScore = loadHighScore();
        let currentLevel = 1;
        let gameState = 'start'; // 'start', 'playing', 'paused', 'gameover'
        let animationFrame = 0;
        let particles = [];
        let shrubs = [];
        let lastUpdateTime = 0;
        let accumulatedTime = 0;
        let animationId = null;
        let idleAnimationId = null;
        let jawAngle = 0; // current jaw-open angle in radians

        // Touch handling state
        let touchStartX = 0;
        let touchStartY = 0;
        const SWIPE_THRESHOLD = 30;

        // ==================== INITIALIZATION ====================
        highScoreEl.textContent = highScore;
        startScreen.style.display = 'block';

        // ==================== UTILITY FUNCTIONS ====================
        function shadeColor(color, percent) {
            const num = parseInt(color.replace('#', ''), 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.max(0, Math.min(255, (num >> 16) + amt));
            const G = Math.max(0, Math.min(255, ((num >> 8) & 0x00FF) + amt));
            const B = Math.max(0, Math.min(255, (num & 0x0000FF) + amt));
            return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
        }

        function getSeasonColors(season) {
            return SEASONS[season] || SEASONS.spring;
        }

        function announce(message) {
            announcer.textContent = message;
        }

        // ==================== VEGETATION GENERATION ====================
        function generateVegetation() {
            shrubs = [];
            const colors = getSeasonColors(LEVELS[currentLevel - 1].season);
            const season = LEVELS[currentLevel - 1].season;

            for (let i = 0; i < SHRUB_COUNT; i++) {
                const edge = Math.floor(Math.random() * 4);
                let x, y;

                if (edge === 0) {
                    x = Math.random() * CANVAS_SIZE;
                    y = Math.random() * SHRUB_EDGE_MARGIN;
                } else if (edge === 1) {
                    x = CANVAS_SIZE - SHRUB_EDGE_MARGIN + Math.random() * SHRUB_EDGE_MARGIN;
                    y = Math.random() * CANVAS_SIZE;
                } else if (edge === 2) {
                    x = Math.random() * CANVAS_SIZE;
                    y = CANVAS_SIZE - SHRUB_EDGE_MARGIN + Math.random() * SHRUB_EDGE_MARGIN;
                } else {
                    x = Math.random() * SHRUB_EDGE_MARGIN;
                    y = Math.random() * CANVAS_SIZE;
                }

                let shrubColor = colors.grass;
                if (season === 'autumn') {
                    shrubColor = Math.random() > 0.5 ? '#8b4513' : colors.grass;
                } else if (season === 'winter') {
                    shrubColor = '#7a9a7a';
                }

                const circles = [];
                for (let j = 0; j < 6; j++) {
                    const offsetX = (Math.random() - 0.5) * 30 * 0.6;
                    const offsetY = (Math.random() - 0.5) * 30 * 0.4;
                    const size = 30 * 0.3 + Math.random() * 30 * 0.3;
                    circles.push({ offsetX, offsetY, size });
                }

                shrubs.push({
                    x: x,
                    y: y,
                    size: 25 + Math.random() * 30,
                    color: shrubColor,
                    circles: circles
                });
            }

            // Pre-render background after generating vegetation
            preRenderBackground();
        }

        // ==================== PRE-RENDERED BACKGROUND ====================
        function preRenderBackground() {
            const colors = getSeasonColors(LEVELS[currentLevel - 1].season);

            // Clear background canvas
            bgCtx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

            // Radial gradient for depth
            const gradient = bgCtx.createRadialGradient(
                CANVAS_SIZE / 2, CANVAS_SIZE / 2, 0,
                CANVAS_SIZE / 2, CANVAS_SIZE / 2, CANVAS_SIZE / 1.3
            );
            gradient.addColorStop(0, colors.ground[1]);
            gradient.addColorStop(0.7, colors.ground[0]);
            gradient.addColorStop(1, colors.ground[0]);
            bgCtx.fillStyle = gradient;
            bgCtx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

            // Pre-render grass with fixed positions (seeded by level)
            const grassPositions = [];
            const seed = currentLevel * 12345;
            for (let i = 0; i < GRASS_COUNT; i++) {
                const pseudoRandom1 = ((seed + i * 7919) % 10000) / 10000;
                const pseudoRandom2 = ((seed + i * 7927) % 10000) / 10000;
                const pseudoRandom3 = ((seed + i * 7933) % 10000) / 10000;
                const pseudoRandom4 = ((seed + i * 7937) % 10000) / 10000;

                grassPositions.push({
                    x: pseudoRandom1 * CANVAS_SIZE,
                    y: pseudoRandom2 * CANVAS_SIZE,
                    length: 8 + pseudoRandom3 * 12,
                    angle: pseudoRandom4 * Math.PI * 2
                });
            }

            grassPositions.forEach(grass => {
                bgCtx.save();
                bgCtx.translate(grass.x, grass.y);
                bgCtx.rotate(grass.angle);

                const grassGradient = bgCtx.createLinearGradient(0, 0, 0, grass.length);
                grassGradient.addColorStop(0, colors.grass);
                grassGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

                bgCtx.strokeStyle = grassGradient;
                bgCtx.lineWidth = 1.5;
                bgCtx.lineCap = 'round';
                bgCtx.globalAlpha = 0.3;
                bgCtx.beginPath();
                bgCtx.moveTo(0, 0);
                bgCtx.lineTo(0, grass.length);
                bgCtx.stroke();
                bgCtx.restore();
            });

            // Pre-render shrubs
            shrubs.forEach(shrub => {
                // Shadow
                bgCtx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                bgCtx.beginPath();
                bgCtx.ellipse(shrub.x, shrub.y + shrub.size * 0.3, shrub.size * 0.7, shrub.size * 0.15, 0, 0, Math.PI * 2);
                bgCtx.fill();

                shrub.circles.forEach(circle => {
                    const circleGradient = bgCtx.createRadialGradient(
                        shrub.x + circle.offsetX - circle.size * 0.3,
                        shrub.y + circle.offsetY - circle.size * 0.3,
                        0,
                        shrub.x + circle.offsetX,
                        shrub.y + circle.offsetY,
                        circle.size
                    );
                    circleGradient.addColorStop(0, shrub.color);
                    circleGradient.addColorStop(1, shadeColor(shrub.color, -35));

                    bgCtx.fillStyle = circleGradient;
                    bgCtx.beginPath();
                    bgCtx.arc(shrub.x + circle.offsetX, shrub.y + circle.offsetY, circle.size, 0, Math.PI * 2);
                    bgCtx.fill();
                });
            });

            // Pre-render light patches with fixed positions
            for (let i = 0; i < LIGHT_PATCH_COUNT; i++) {
                const pseudoRandom1 = ((currentLevel * 54321 + i * 7919) % 10000) / 10000;
                const pseudoRandom2 = ((currentLevel * 54321 + i * 7927) % 10000) / 10000;
                const pseudoRandom3 = ((currentLevel * 54321 + i * 7933) % 10000) / 10000;

                const x = pseudoRandom1 * CANVAS_SIZE;
                const y = pseudoRandom2 * CANVAS_SIZE;
                const size = 100 + pseudoRandom3 * 200;

                const lightGradient = bgCtx.createRadialGradient(x, y, 0, x, y, size);
                lightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.05)');
                lightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

                bgCtx.fillStyle = lightGradient;
                bgCtx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            }

            // Pebbles / stones scattered on the ground
            for (let i = 0; i < 40; i++) {
                const pr1 = ((currentLevel * 44444 + i * 6197) % 10000) / 10000;
                const pr2 = ((currentLevel * 44444 + i * 6199) % 10000) / 10000;
                const pr3 = ((currentLevel * 44444 + i * 6203) % 10000) / 10000;
                const pr4 = ((currentLevel * 44444 + i * 6211) % 10000) / 10000;
                const px = pr1 * CANVAS_SIZE;
                const py = pr2 * CANVAS_SIZE;
                const pSz = 3.5 + pr3 * 7;
                const pAng = pr4 * Math.PI;
                const pG = bgCtx.createRadialGradient(px - pSz * 0.3, py - pSz * 0.3, 0, px, py, pSz);
                pG.addColorStop(0, '#c8c5b8');
                pG.addColorStop(0.7, '#9a9888');
                pG.addColorStop(1, '#6a6860');
                bgCtx.fillStyle = pG;
                bgCtx.globalAlpha = 0.55 + pr3 * 0.3;
                bgCtx.beginPath();
                bgCtx.ellipse(px, py, pSz, pSz * 0.62, pAng, 0, Math.PI * 2);
                bgCtx.fill();
                bgCtx.strokeStyle = 'rgba(70,65,55,0.28)';
                bgCtx.lineWidth = 0.5;
                bgCtx.stroke();
            }
            bgCtx.globalAlpha = 1;

            // Seasonal ground details
            const detailSeason = LEVELS[currentLevel - 1].season;
            if (detailSeason === 'autumn') {
                // Fallen leaves
                const leafColors = ['#d84315', '#e65100', '#f57c00', '#bf360c', '#8d6e63'];
                for (let i = 0; i < 90; i++) {
                    const r1 = ((currentLevel * 13579 + i * 3137) % 10000) / 10000;
                    const r2 = ((currentLevel * 13579 + i * 3163) % 10000) / 10000;
                    const r3 = ((currentLevel * 13579 + i * 3167) % 10000) / 10000;
                    const r4 = ((currentLevel * 13579 + i * 3169) % 10000) / 10000;
                    bgCtx.save();
                    bgCtx.translate(r1 * CANVAS_SIZE, r2 * CANVAS_SIZE);
                    bgCtx.rotate(r4 * Math.PI * 2);
                    bgCtx.fillStyle = leafColors[Math.floor(r3 * 5)];
                    bgCtx.globalAlpha = 0.45 + r3 * 0.3;
                    bgCtx.beginPath();
                    bgCtx.ellipse(0, 0, 5 + r3 * 3, 3 + r3 * 2, 0, 0, Math.PI * 2);
                    bgCtx.fill();
                    bgCtx.restore();
                }
            } else if (detailSeason === 'winter') {
                // Snow drifts
                for (let i = 0; i < 45; i++) {
                    const r1 = ((currentLevel * 22222 + i * 4157) % 10000) / 10000;
                    const r2 = ((currentLevel * 22222 + i * 4159) % 10000) / 10000;
                    const r3 = ((currentLevel * 22222 + i * 4177) % 10000) / 10000;
                    const sx = r1 * CANVAS_SIZE;
                    const sy = r2 * CANVAS_SIZE;
                    const snowR = 18 + r3 * 38;
                    const snowG = bgCtx.createRadialGradient(sx, sy, 0, sx, sy, snowR);
                    snowG.addColorStop(0, 'rgba(255,255,255,0.55)');
                    snowG.addColorStop(1, 'rgba(255,255,255,0)');
                    bgCtx.fillStyle = snowG;
                    bgCtx.beginPath();
                    bgCtx.arc(sx, sy, snowR, 0, Math.PI * 2);
                    bgCtx.fill();
                }
            } else if (detailSeason === 'spring') {
                // Wildflowers
                const flowerColors = ['#f48fb1', '#ffcc80', '#ce93d8', '#81d4fa', '#a5d6a7'];
                for (let i = 0; i < 55; i++) {
                    const r1 = ((currentLevel * 33333 + i * 5171) % 10000) / 10000;
                    const r2 = ((currentLevel * 33333 + i * 5179) % 10000) / 10000;
                    const r3 = ((currentLevel * 33333 + i * 5189) % 10000) / 10000;
                    bgCtx.fillStyle = flowerColors[Math.floor(r3 * 5)];
                    bgCtx.globalAlpha = 0.65;
                    bgCtx.beginPath();
                    bgCtx.arc(r1 * CANVAS_SIZE, r2 * CANVAS_SIZE, 2.5, 0, Math.PI * 2);
                    bgCtx.fill();
                    bgCtx.fillStyle = '#fff9c4';
                    bgCtx.globalAlpha = 0.85;
                    bgCtx.beginPath();
                    bgCtx.arc(r1 * CANVAS_SIZE, r2 * CANVAS_SIZE, 0.9, 0, Math.PI * 2);
                    bgCtx.fill();
                }
            } else if (detailSeason === 'void') {
                // Cracked earth lines
                bgCtx.globalAlpha = 0.22;
                bgCtx.strokeStyle = '#9e9e9e';
                bgCtx.lineWidth = 1;
                for (let i = 0; i < 20; i++) {
                    const r1 = ((currentLevel * 55555 + i * 7213) % 10000) / 10000;
                    const r2 = ((currentLevel * 55555 + i * 7219) % 10000) / 10000;
                    const r3 = ((currentLevel * 55555 + i * 7229) % 10000) / 10000;
                    const vLen = 30 + r3 * 80;
                    const vAng = r3 * Math.PI;
                    const vx = r1 * CANVAS_SIZE;
                    const vy = r2 * CANVAS_SIZE;
                    bgCtx.beginPath();
                    bgCtx.moveTo(vx, vy);
                    bgCtx.lineTo(vx + Math.cos(vAng) * vLen, vy + Math.sin(vAng) * vLen);
                    bgCtx.stroke();
                }
            }
            bgCtx.globalAlpha = 1;
        }

        function drawBackground() {
            // Simply draw the pre-rendered background
            ctx.drawImage(bgCanvas, 0, 0);
        }

        // ==================== PARTICLES ====================
        function initParticles() {
            particles = [];
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                particles.push({
                    x: Math.random() * CANVAS_SIZE,
                    y: Math.random() * CANVAS_SIZE,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: 0.3 + Math.random() * 0.7,
                    size: 2 + Math.random() * 4,
                    opacity: 0.3 + Math.random() * 0.5,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.05
                });
            }
        }

        function updateParticles() {
            particles.forEach(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.rotation += p.rotationSpeed;

                if (p.y > CANVAS_SIZE) {
                    p.y = -10;
                    p.x = Math.random() * CANVAS_SIZE;
                }
                if (p.x < -10) p.x = CANVAS_SIZE + 10;
                if (p.x > CANVAS_SIZE + 10) p.x = -10;
            });
        }

        // Cache a small offscreen canvas per season color to stamp particles cheaply
        const particleCache = {};
        function getParticleStamp(color, maxSize) {
            const key = color + maxSize;
            if (particleCache[key]) return particleCache[key];
            const size = Math.ceil(maxSize) * 2 + 2;
            const stamp = document.createElement('canvas');
            stamp.width = size;
            stamp.height = size;
            const sc = stamp.getContext('2d');
            const cx = size / 2;
            const grad = sc.createRadialGradient(cx, cx, 0, cx, cx, maxSize);
            grad.addColorStop(0, color);
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            sc.fillStyle = grad;
            sc.beginPath();
            sc.arc(cx, cx, maxSize, 0, Math.PI * 2);
            sc.fill();
            particleCache[key] = stamp;
            return stamp;
        }

        function drawParticles() {
            const colors = getSeasonColors(LEVELS[currentLevel - 1].season);

            particles.forEach(p => {
                const stamp = getParticleStamp(colors.particle, p.size);
                const half = stamp.width / 2;
                ctx.save();
                ctx.globalAlpha = p.opacity;
                ctx.translate(p.x, p.y);
                ctx.rotate(p.rotation);
                ctx.drawImage(stamp, -half, -half);
                ctx.restore();
            });
        }

        // ==================== SNAKE RENDERING ====================
        function drawRealisticSnake() {
            if (snake.length === 0) return;

            const screenSegments = snake.map(s => ({
                x: s.x * TILE_SIZE + TILE_SIZE / 2,
                y: s.y * TILE_SIZE + TILE_SIZE / 2,
                gridX: s.x,
                gridY: s.y
            }));

            const continuousSegments = [];
            const segmentStartIndices = [];
            let currentSegment = [screenSegments[0]];
            let currentStartIndex = 0;

            for (let i = 1; i < screenSegments.length; i++) {
                const prev = snake[i - 1];
                const curr = snake[i];
                const wrapsHorizontal = Math.abs(prev.x - curr.x) > GRID_SIZE / 2;
                const wrapsVertical = Math.abs(prev.y - curr.y) > GRID_SIZE / 2;
                if (wrapsHorizontal || wrapsVertical) {
                    segmentStartIndices.push(currentStartIndex);
                    continuousSegments.push(currentSegment);
                    currentStartIndex = i;
                    currentSegment = [screenSegments[i]];
                } else {
                    currentSegment.push(screenSegments[i]);
                }
            }
            segmentStartIndices.push(currentStartIndex);
            continuousSegments.push(currentSegment);

            continuousSegments.forEach((segment, segIndex) => {
                if (segment.length === 0) return;
                const globalOffset = segmentStartIndices[segIndex];

                // Helper: draw the curved body path
                function buildBodyPath() {
                    ctx.beginPath();
                    ctx.moveTo(segment[0].x, segment[0].y);
                    for (let i = 1; i < segment.length; i++) {
                        const xc = (segment[i].x + segment[i - 1].x) / 2;
                        const yc = (segment[i].y + segment[i - 1].y) / 2;
                        ctx.quadraticCurveTo(segment[i - 1].x, segment[i - 1].y, xc, yc);
                    }
                    ctx.lineTo(segment[segment.length - 1].x, segment[segment.length - 1].y);
                }

                // --- CAST SHADOW ---
                if (segment.length > 1) {
                    ctx.save();
                    ctx.shadowColor = 'rgba(0,0,0,0.5)';
                    ctx.shadowBlur = 10;
                    ctx.shadowOffsetX = 5;
                    ctx.shadowOffsetY = 6;
                    ctx.strokeStyle = 'rgba(0,0,0,0.01)';
                    ctx.lineWidth = TILE_SIZE + 4;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    buildBodyPath();
                    ctx.stroke();
                    ctx.restore();
                }

                // --- DARK OUTLINE ---
                if (segment.length > 1) {
                    ctx.save();
                    ctx.strokeStyle = '#0a1e0a';
                    ctx.lineWidth = TILE_SIZE + 6;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    buildBodyPath();
                    ctx.stroke();
                    ctx.restore();
                }

                // --- VENTRAL (belly) — cream centre band, full width ---
                if (segment.length > 1) {
                    ctx.save();
                    const bellyG = ctx.createLinearGradient(
                        0, segment[0].y - TILE_SIZE / 2,
                        0, segment[0].y + TILE_SIZE / 2
                    );
                    bellyG.addColorStop(0,    '#2d5a2d');
                    bellyG.addColorStop(0.38, '#c8ba7a');
                    bellyG.addColorStop(0.62, '#c8ba7a');
                    bellyG.addColorStop(1,    '#2d5a2d');
                    ctx.strokeStyle = bellyG;
                    ctx.lineWidth = TILE_SIZE - 1;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    buildBodyPath();
                    ctx.stroke();
                    ctx.restore();
                }

                // --- DORSAL (back) — rich green, narrower ---
                if (segment.length > 1) {
                    ctx.save();
                    const dorsalG = ctx.createLinearGradient(
                        0, segment[0].y - TILE_SIZE / 2,
                        0, segment[0].y + TILE_SIZE / 2
                    );
                    dorsalG.addColorStop(0,    '#1a3a1a');
                    dorsalG.addColorStop(0.28, '#3d7a3d');
                    dorsalG.addColorStop(0.5,  '#5aaa5a');
                    dorsalG.addColorStop(0.72, '#3d7a3d');
                    dorsalG.addColorStop(1,    '#1a3a1a');
                    ctx.strokeStyle = dorsalG;
                    ctx.lineWidth = TILE_SIZE * 0.72;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    buildBodyPath();
                    ctx.stroke();
                    ctx.restore();
                }

                // --- DORSAL MIDLINE STRIPE ---
                if (segment.length > 1) {
                    ctx.save();
                    ctx.strokeStyle = 'rgba(10,35,10,0.5)';
                    ctx.lineWidth = TILE_SIZE * 0.16;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    buildBodyPath();
                    ctx.stroke();
                    ctx.restore();
                }

                // --- SPECULAR HIGHLIGHT SHEEN ---
                if (segment.length > 1) {
                    ctx.save();
                    ctx.strokeStyle = 'rgba(160,230,160,0.16)';
                    ctx.lineWidth = TILE_SIZE * 0.24;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    buildBodyPath();
                    ctx.stroke();
                    ctx.restore();
                }

                // --- SCALE TEXTURE ---
                // Each scale is an ellipse oriented perpendicular to body direction.
                // Alternating row offset gives overlapping tile effect.
                segment.forEach((point, i) => {
                    const globalIndex = globalOffset + i;
                    const t = globalIndex / Math.max(snake.length - 1, 1);
                    const size = (TILE_SIZE / 2.2) * (1 - t * 0.45);

                    // Direction along body at this point
                    let angle = 0;
                    if (i < segment.length - 1) {
                        angle = Math.atan2(segment[i + 1].y - point.y, segment[i + 1].x - point.x);
                    } else if (i > 0) {
                        angle = Math.atan2(point.y - segment[i - 1].y, point.x - segment[i - 1].x);
                    }

                    ctx.save();
                    ctx.translate(point.x, point.y);
                    ctx.rotate(angle);

                    // In rotated space: local-x = along body, local-y = perpendicular (right side)
                    const rowOff = (globalIndex % 2 === 0) ? size * 0.14 : -size * 0.14;
                    for (let s = -1; s <= 1; s += 2) {
                        const sx = rowOff;           // slight stagger along body
                        const sy = s * size * 0.54;  // left/right of body
                        const sL = size * 0.32;      // extent along body
                        const sW = size * 0.44;      // extent perpendicular

                        ctx.globalAlpha = 0.5;
                        ctx.fillStyle = '#3d7a3d';
                        ctx.beginPath();
                        ctx.ellipse(sx, sy, sL, sW, 0, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.globalAlpha = 0.18;
                        ctx.fillStyle = '#a8d8a8';
                        ctx.beginPath();
                        ctx.ellipse(sx - sL * 0.22, sy - sW * 0.28, sL * 0.38, sW * 0.3, 0, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.globalAlpha = 0.32;
                        ctx.strokeStyle = '#0f2a0f';
                        ctx.lineWidth = 0.7;
                        ctx.beginPath();
                        ctx.ellipse(sx, sy, sL, sW, 0, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    ctx.restore();
                });
            });

            // ==================== REALISTIC HEAD ====================
            const head = screenSegments[0];
            const H = TILE_SIZE / 1.55;   // head length (forward)
            const N = TILE_SIZE / 1.95;   // head half-width at widest
            const hingeX = -N * 0.15;     // jaw-hinge local-x

            let headAngle;
            if (screenSegments.length > 1) {
                const neck = screenSegments[1];
                headAngle = Math.atan2(head.y - neck.y, head.x - neck.x);
            } else {
                headAngle = Math.atan2(direction.y, direction.x);
            }

            ctx.save();
            ctx.translate(head.x, head.y);
            ctx.rotate(headAngle);

            // Ambient head glow
            const glowR = H * 1.7;
            const headGlowG = ctx.createRadialGradient(H * 0.2, 0, H * 0.1, 0, 0, glowR);
            headGlowG.addColorStop(0, 'rgba(70,185,70,0.2)');
            headGlowG.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = headGlowG;
            ctx.beginPath();
            ctx.arc(0, 0, glowR, 0, Math.PI * 2);
            ctx.fill();

            // Head cast shadow
            ctx.save();
            ctx.shadowColor = 'rgba(0,0,0,0.55)';
            ctx.shadowBlur = 12;
            ctx.shadowOffsetX = 6;
            ctx.shadowOffsetY = 7;
            ctx.fillStyle = 'rgba(0,0,0,0.01)';
            ctx.beginPath();
            ctx.moveTo(hingeX - N * 0.35, -N * 1.05);
            ctx.bezierCurveTo(H * 0.35, -N * 1.15, H * 0.88, -N * 0.5, H + 7, 0);
            ctx.bezierCurveTo(H * 0.88, N * 0.5, H * 0.35, N * 1.15, hingeX - N * 0.35, N * 1.05);
            ctx.closePath();
            ctx.fill();
            ctx.restore();

            // ===== LOWER JAW (drawn first, behind skull) =====
            ctx.save();
            ctx.translate(hingeX, 0);
            ctx.rotate(jawAngle); // rotate about the jaw hinge
            ctx.translate(-hingeX, 0);

            // Lower jaw exterior
            const ljG = ctx.createLinearGradient(hingeX, 0, H, N);
            ljG.addColorStop(0,    '#2a5a2a');
            ljG.addColorStop(0.55, '#4d8a4d');
            ljG.addColorStop(1,    '#b0a068');
            ctx.fillStyle = ljG;
            ctx.beginPath();
            ctx.moveTo(hingeX, N * 0.1);
            ctx.bezierCurveTo(H * 0.18, N * 1.0,  H * 0.72, N * 0.88, H + 5, N * 0.08);
            ctx.bezierCurveTo(H + 2,    -N * 0.04, H * 0.55, -N * 0.08, hingeX, -N * 0.1);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#0a1a0a';
            ctx.lineWidth = 1.2;
            ctx.stroke();

            // Chin midline groove
            ctx.strokeStyle = 'rgba(8,25,8,0.38)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(hingeX + 5, 0);
            ctx.bezierCurveTo(H * 0.38, N * 0.07, H * 0.78, N * 0.04, H + 3, 0);
            ctx.stroke();

            // Mouth lining — vivid pink/red, visible as jaw opens
            if (jawAngle > 0.02) {
                const mOpen = Math.min(1, jawAngle / MAX_JAW_ANGLE);
                ctx.save();
                ctx.globalAlpha = mOpen * 0.95;
                const mG = ctx.createLinearGradient(hingeX, 0, H + 4, 0);
                mG.addColorStop(0,   '#aa2222');
                mG.addColorStop(0.5, '#ee4444');
                mG.addColorStop(1,   '#cc3333');
                ctx.fillStyle = mG;
                ctx.beginPath();
                ctx.moveTo(hingeX + 4, -N * 0.06);
                ctx.bezierCurveTo(H * 0.28, N * 0.62 * mOpen, H * 0.72, N * 0.5 * mOpen, H + 3, N * 0.03);
                ctx.bezierCurveTo(H * 0.72, -N * 0.04, H * 0.28, -N * 0.04, hingeX + 4, -N * 0.06);
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }

            // Lower teeth
            if (jawAngle > 0.1) {
                const tA = Math.min(1, (jawAngle - 0.07) / (MAX_JAW_ANGLE * 0.55));
                ctx.save();
                ctx.globalAlpha = tA;
                ctx.fillStyle = '#f0e8cf';
                const tCount = 7;
                const tStartX = hingeX + 12;
                const tSpace  = (H - tStartX - 10) / tCount;
                for (let t = 0; t < tCount; t++) {
                    const tx = tStartX + t * tSpace;
                    const th = 3.5 + (t === 3 ? 1.5 : 0);
                    ctx.beginPath();
                    ctx.moveTo(tx, -1.5);
                    ctx.lineTo(tx + 3.5, -1.5);
                    ctx.lineTo(tx + 1.75, -(1.5 + th));
                    ctx.closePath();
                    ctx.fill();
                }
                ctx.restore();
            }

            ctx.restore(); // end lower jaw rotation

            // ===== UPPER SKULL =====
            // Neck junction
            const nkG = ctx.createRadialGradient(-N * 0.5, 0, 0, 0, 0, N);
            nkG.addColorStop(0,   '#4d8a4d');
            nkG.addColorStop(0.6, '#2d5a2d');
            nkG.addColorStop(1,   '#1a3a1a');
            ctx.fillStyle = nkG;
            ctx.beginPath();
            ctx.ellipse(-N * 0.5, 0, N * 0.75, N * 0.9, 0, 0, Math.PI * 2);
            ctx.fill();

            // Main skull — triangular wedge with bezier curves
            const skG = ctx.createLinearGradient(hingeX - N * 0.3, -N, H + 7, 0);
            skG.addColorStop(0,   '#3a7a3a');
            skG.addColorStop(0.3, '#5aaa5a');
            skG.addColorStop(0.6, '#4a9a4a');
            skG.addColorStop(1,   '#2d5a2d');
            ctx.fillStyle = skG;
            ctx.beginPath();
            ctx.moveTo(hingeX - N * 0.25, -N * 1.08);
            ctx.bezierCurveTo(H * 0.22, -N * 1.18, H * 0.82, -N * 0.58, H + 7, -N * 0.11);
            ctx.lineTo(H + 7, N * 0.11);
            ctx.bezierCurveTo(H * 0.82, N * 0.58, H * 0.22, N * 1.18, hingeX - N * 0.25, N * 1.08);
            ctx.bezierCurveTo(-N * 0.7, N * 0.88, -N * 0.7, -N * 0.88, hingeX - N * 0.25, -N * 1.08);
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = '#0a1a0a';
            ctx.lineWidth = 1.5;
            ctx.stroke();

            // Upper jaw / lip seam line
            ctx.strokeStyle = '#0a1a0a';
            ctx.lineWidth = 1.3;
            ctx.beginPath();
            ctx.moveTo(hingeX, 0);
            ctx.bezierCurveTo(H * 0.3, N * 0.2, H * 0.8, N * 0.1, H + 6, 0);
            ctx.stroke();

            // Dorsal ridge / median head groove
            ctx.save();
            ctx.strokeStyle = 'rgba(8,30,8,0.45)';
            ctx.lineWidth = 1.6;
            ctx.beginPath();
            ctx.moveTo(hingeX, -N * 0.28);
            ctx.bezierCurveTo(H * 0.3, -N * 0.58, H * 0.72, -N * 0.46, H, -N * 0.1);
            ctx.stroke();
            ctx.restore();

            // Head scale plate outlines (parietal + prefrontal)
            ctx.save();
            ctx.globalAlpha = 0.25;
            ctx.strokeStyle = '#0d2b0d';
            ctx.lineWidth = 0.9;
            [-1, 1].forEach(side => {
                ctx.beginPath();
                ctx.ellipse(H * 0.18, side * N * 0.46, H * 0.24, N * 0.35, 0.12 * side, 0, Math.PI * 2);
                ctx.stroke();
            });
            ctx.beginPath();
            ctx.ellipse(H * 0.14, 0, H * 0.15, N * 0.28, 0, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();

            // Heat-sensing loreal pits (between eye and nostril)
            ctx.fillStyle = '#0a1a0a';
            [-1, 1].forEach(side => {
                ctx.beginPath();
                ctx.ellipse(H * 0.58, side * N * 0.66, 2.5, 1.7, 0, 0, Math.PI * 2);
                ctx.fill();
            });

            // Nostrils
            ctx.fillStyle = '#0a1a0a';
            [-1, 1].forEach(side => {
                ctx.beginPath();
                ctx.ellipse(H * 0.84, side * N * 0.5, 2.8, 1.8, 0.35 * side, 0, Math.PI * 2);
                ctx.fill();
            });

            // Upper fangs — emerge as jaw opens
            if (jawAngle > 0.12) {
                const fA = Math.min(1, (jawAngle - 0.08) / (MAX_JAW_ANGLE * 0.45));
                ctx.save();
                ctx.globalAlpha = fA;
                ctx.fillStyle = '#f5edda';
                [-1, 1].forEach(side => {
                    const fy = side * N * 0.2;
                    ctx.beginPath();
                    ctx.moveTo(H * 0.65 - 2.5, fy - 1);
                    ctx.lineTo(H * 0.65 + 2.5, fy - 1);
                    ctx.lineTo(H * 0.65, fy + side * 11);
                    ctx.closePath();
                    ctx.fill();
                    // Fang groove
                    ctx.strokeStyle = 'rgba(210,185,130,0.55)';
                    ctx.lineWidth = 0.8;
                    ctx.beginPath();
                    ctx.moveTo(H * 0.65, fy);
                    ctx.lineTo(H * 0.65, fy + side * 9);
                    ctx.stroke();
                });
                ctx.restore();
            }

            // ===== EYES with vertical slit pupils =====
            const eyeX = H * 0.33;
            const eyeR = 5.8;
            [-1, 1].forEach(side => {
                const ey = side * N * 0.64;

                // Eye socket depression
                ctx.fillStyle = '#182818';
                ctx.beginPath();
                ctx.arc(eyeX, ey, eyeR + 2.8, 0, Math.PI * 2);
                ctx.fill();

                // Iris — amber/gold radial gradient
                const irisG = ctx.createRadialGradient(eyeX - 1.2, ey - 1.4, 0, eyeX, ey, eyeR);
                irisG.addColorStop(0,    '#f0d040');
                irisG.addColorStop(0.5,  '#c8a010');
                irisG.addColorStop(0.82, '#9a7000');
                irisG.addColorStop(1,    '#504000');
                ctx.fillStyle = irisG;
                ctx.beginPath();
                ctx.arc(eyeX, ey, eyeR, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = '#1a1000';
                ctx.lineWidth = 0.9;
                ctx.stroke();

                // Vertical slit pupil
                ctx.fillStyle = '#080808';
                ctx.save();
                ctx.translate(eyeX, ey);
                ctx.beginPath();
                ctx.ellipse(0, 0, eyeR * 0.24, eyeR * 0.82, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                // Spectacle scale rim
                ctx.strokeStyle = 'rgba(190,230,190,0.2)';
                ctx.lineWidth = 1.3;
                ctx.beginPath();
                ctx.arc(eyeX, ey, eyeR + 1.2, 0, Math.PI * 2);
                ctx.stroke();

                // Catchlight
                ctx.fillStyle = 'rgba(255,255,255,0.75)';
                ctx.beginPath();
                ctx.arc(eyeX - 1.8, ey - 2, 1.9, 0, Math.PI * 2);
                ctx.fill();
            });

            // ===== TONGUE =====
            // Always shows faint flicker; fully extends near food or when jaw is open
            const foodDist = (food.x !== undefined)
                ? Math.abs(snake[0].x - food.x) + Math.abs(snake[0].y - food.y)
                : 999;
            const tongueVisible = jawAngle > 0.06 || foodDist <= 5;
            if (tongueVisible) {
                const tOpacity = Math.max(
                    jawAngle > 0.06 ? jawAngle / MAX_JAW_ANGLE : 0,
                    foodDist <= 5 ? 0.88 : 0.45
                );
                const flick     = Math.sin(animationFrame * 0.48) * 4;
                const baseLen   = 13 + Math.abs(Math.sin(animationFrame * 0.32)) * 10;
                const forkLen   = 7.5;
                const tBase     = H + 6;

                ctx.save();
                ctx.globalAlpha = tOpacity;
                ctx.strokeStyle = '#c41e3a';
                ctx.lineCap = 'round';

                // Tongue shaft
                ctx.lineWidth = 2.2;
                ctx.beginPath();
                ctx.moveTo(tBase - 2, 0);
                ctx.lineTo(tBase + baseLen * 0.62, flick * 0.22);
                ctx.stroke();

                // Forked tips
                ctx.lineWidth = 1.6;
                ctx.beginPath();
                ctx.moveTo(tBase + baseLen * 0.62, flick * 0.22);
                ctx.lineTo(tBase + baseLen + forkLen, -5.5 + flick);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(tBase + baseLen * 0.62, flick * 0.22);
                ctx.lineTo(tBase + baseLen + forkLen,  5.5 + flick);
                ctx.stroke();
                ctx.restore();
            }

            ctx.restore(); // end head transform
        }

        // ==================== FOOD RENDERING ====================
        const foodSpriteCache = {};
        function getFoodSprite(type) {
            if (foodSpriteCache[type]) return foodSpriteCache[type];
            const EMOJI_MAP = { APPLE: '🍎', MOUSE: '🐭', RABBIT: '🐰' };
            const SIZE = Math.round(TILE_SIZE * 1.4);
            const PAD  = 8;
            const w    = SIZE + PAD * 2;
            const oc   = document.createElement('canvas');
            oc.width = w; oc.height = w;
            const sc   = oc.getContext('2d');
            sc.font = `${SIZE}px serif`;
            sc.textAlign = 'center';
            sc.textBaseline = 'middle';
            sc.fillText(EMOJI_MAP[type], w / 2, w / 2);
            foodSpriteCache[type] = oc;
            return oc;
        }

        function drawFoodGlow(fx, fy, r, g, b, baseRadius) {
            // Breathing glow ring around food
            const pulse = 0.5 + 0.5 * Math.sin(animationFrame * 0.12);
            const glowRadius = baseRadius + 6 + pulse * 8;
            const innerAlpha = 0.35 + pulse * 0.2;
            const glowGrad = ctx.createRadialGradient(fx, fy, baseRadius * 0.6, fx, fy, glowRadius);
            glowGrad.addColorStop(0, `rgba(${r},${g},${b},${innerAlpha.toFixed(2)})`);
            glowGrad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = glowGrad;
            ctx.beginPath();
            ctx.arc(fx, fy, glowRadius, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawRealisticFood() {
            if (food.x === undefined || food.y === undefined) return;

            const fx     = food.x * TILE_SIZE + TILE_SIZE / 2;
            const fy     = food.y * TILE_SIZE + TILE_SIZE / 2;
            const sprite = getFoodSprite(food.type);
            const sw     = sprite.width;

            if (food.type === 'RABBIT') {
                drawFoodGlow(fx, fy, 240, 240, 200, 16);
                const hopT       = Math.abs(Math.sin(animationFrame * 0.15));
                const hop        = hopT * 15;
                const ry         = fy - hop;
                const shadowScaleX = 1 - hopT * 0.55;
                const peakScale  = 1 + hopT * 0.12;

                // Dynamic shadow — shrinks as rabbit rises
                ctx.save();
                ctx.fillStyle = 'rgba(0,0,0,0.35)';
                ctx.beginPath();
                ctx.ellipse(fx, fy + 3, 16 * shadowScaleX, 6 * shadowScaleX, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();

                // Emoji sprite with scale pulse at hop peak
                ctx.save();
                ctx.translate(fx, ry);
                ctx.scale(peakScale, peakScale);
                ctx.drawImage(sprite, -sw / 2, -sw / 2, sw, sw);
                ctx.restore();

            } else if (food.type === 'MOUSE') {
                drawFoodGlow(fx, fy, 160, 160, 160, 12);
                // Lateral quiver simulates nervous twitching
                const quiver = Math.sin(animationFrame * 0.9) * 0.8;

                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.ellipse(fx + quiver, fy + 3, 14, 5, 0, 0, Math.PI * 2);
                ctx.fill();

                // Emoji sprite with quiver offset
                ctx.save();
                ctx.translate(fx + quiver, fy);
                ctx.drawImage(sprite, -sw / 2, -sw / 2, sw, sw);
                ctx.restore();

            } else {
                // Apple — gentle bob + subtle scale pulse
                drawFoodGlow(fx, fy, 229, 57, 53, 13);
                const bob   = Math.sin(animationFrame * 0.07) * 2;
                const pulse = 1 + Math.sin(animationFrame * 0.09) * 0.04;

                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.beginPath();
                ctx.ellipse(fx, fy + 3, 11, 4, 0, 0, Math.PI * 2);
                ctx.fill();

                // Emoji sprite with bob and scale pulse
                ctx.save();
                ctx.translate(fx, fy + bob);
                ctx.scale(pulse, pulse);
                ctx.drawImage(sprite, -sw / 2, -sw / 2, sw, sw);
                ctx.restore();
            }
        }

        // ==================== GAME LOGIC ====================
        function spawnFood() {
            // Clear probability-based food selection
            // APPLE: 60%, MOUSE: 30%, RABBIT: 10%
            const rand = Math.random();
            let type;

            if (rand < FOOD_TYPES.RABBIT.probability) {
                // 0 to 0.1 (10%)
                type = 'RABBIT';
            } else if (rand < FOOD_TYPES.RABBIT.probability + FOOD_TYPES.MOUSE.probability) {
                // 0.1 to 0.4 (30%)
                type = 'MOUSE';
            } else {
                // 0.4 to 1.0 (60%)
                type = 'APPLE';
            }

            let x, y;
            let attempts = 0;

            do {
                x = Math.floor(Math.random() * GRID_SIZE);
                y = Math.floor(Math.random() * GRID_SIZE);
                attempts++;

                if (attempts >= MAX_FOOD_SPAWN_ATTEMPTS) {
                    break;
                }
            } while (snake.some(s => s.x === x && s.y === y));

            food = {
                x: x,
                y: y,
                type: type,
                points: FOOD_TYPES[type].points
            };
        }

        function checkLevelUp() {
            if (score >= LEVELS[currentLevel - 1].pointsNeeded && currentLevel < LEVELS.length) {
                currentLevel++;
                updateLevel();
                generateVegetation();
                initParticles();
                // Trigger expanding ring burst at screen centre
                levelUpBurst = { x: CANVAS_SIZE / 2, y: CANVAS_SIZE / 2, radius: 30, alpha: 1 };
                // CSS flash on the level indicator
                levelEl.classList.remove('level-flash');
                void levelEl.offsetWidth; // force reflow to restart animation
                levelEl.classList.add('level-flash');
                announce('Level ' + currentLevel + '!');
            }
        }

        function updateScore() {
            scoreEl.textContent = score;
            // Score pop animation
            scoreEl.classList.remove('score-pop');
            void scoreEl.offsetWidth; // force reflow
            scoreEl.classList.add('score-pop');
            if (score > highScore) {
                highScore = score;
                saveHighScore(highScore);
                highScoreEl.textContent = highScore;
            }
        }

        function updateLevel() {
            levelEl.textContent = currentLevel;
        }

        function gameOver() {
            gameState = 'gameover';
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            deathFlashAlpha = 0.65; // trigger red flash
            finalScoreEl.textContent = score;
            finalLevelEl.textContent = currentLevel;
            // Show game over screen after the flash draws one frame
            requestAnimationFrame(() => {
                draw();
                setTimeout(() => {
                    gameOverScreen.style.display = 'block';
                    startIdleAnimation();
                }, 400);
            });
            announce('Game over. Final score: ' + score);
        }

        // ==================== ERROR DISPLAY ====================
        function showErrorOverlay() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.88)';
            ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            ctx.shadowBlur = 0;
            ctx.textAlign = 'center';
            ctx.fillStyle = '#ff4444';
            ctx.font = 'bold 26px Segoe UI, sans-serif';
            ctx.fillText('Something went wrong', CANVAS_SIZE / 2, CANVAS_SIZE / 2 - 24);
            ctx.fillStyle = '#cccccc';
            ctx.font = '16px Segoe UI, sans-serif';
            ctx.fillText('Please refresh the page to restart.', CANVAS_SIZE / 2, CANVAS_SIZE / 2 + 18);
        }

        // ==================== GAME LOOP (requestAnimationFrame) ====================
        function gameLoop(timestamp) {
            if (gameState !== 'playing') return;

            try {
                if (!lastUpdateTime) {
                    lastUpdateTime = timestamp;
                }

                const deltaTime = timestamp - lastUpdateTime;
                lastUpdateTime = timestamp;
                accumulatedTime += deltaTime;

                const currentSpeed = LEVELS[currentLevel - 1].speed;

                while (accumulatedTime >= currentSpeed) {
                    update();
                    accumulatedTime -= currentSpeed;

                    if (gameState !== 'playing') {
                        return;
                    }
                }

                draw();
                animationId = requestAnimationFrame(gameLoop);
            } catch (err) {
                gameState = 'gameover';
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
                showErrorOverlay();
                announce('An error occurred. Please refresh the page.');
            }
        }

        function updateJawAngle() {
            if (food.x === undefined || gameState !== 'playing') {
                jawAngle = Math.max(0, jawAngle - 0.06);
                return;
            }
            const dist = Math.abs(snake[0].x - food.x) + Math.abs(snake[0].y - food.y);
            const targetAngle = dist <= JAW_OPEN_DISTANCE
                ? MAX_JAW_ANGLE * (1 - dist / (JAW_OPEN_DISTANCE + 1))
                : 0;
            jawAngle += (targetAngle - jawAngle) * 0.22;
            if (jawAngle < 0.008) jawAngle = 0;
        }

        function update() {
            direction.x = nextDirection.x;
            direction.y = nextDirection.y;
            updateJawAngle();

            let headX = snake[0].x + direction.x;
            let headY = snake[0].y + direction.y;

            // Wrap around
            if (headX < 0) headX = GRID_SIZE - 1;
            if (headX >= GRID_SIZE) headX = 0;
            if (headY < 0) headY = GRID_SIZE - 1;
            if (headY >= GRID_SIZE) headY = 0;

            // Self collision
            if (snake.some(s => s.x === headX && s.y === headY)) {
                gameOver();
                return;
            }

            snake.unshift({ x: headX, y: headY });

            // Failsafe: ensure food exists
            if (food.x === undefined || food.y === undefined) {
                spawnFood();
            }

            if (headX === food.x && headY === food.y) {
                score += food.points;
                updateScore();
                spawnFood();
                checkLevelUp();
            } else {
                snake.pop();
            }

            animationFrame++;
            updateParticles();
        }

        function drawLevelUpBurst() {
            if (!levelUpBurst) return;
            const b = levelUpBurst;
            ctx.save();
            ctx.globalAlpha = b.alpha;
            ctx.strokeStyle = '#7CFC00';
            ctx.lineWidth = 4;
            ctx.shadowColor = '#7CFC00';
            ctx.shadowBlur = 20;
            ctx.beginPath();
            ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();

            b.radius += 10;
            b.alpha -= 0.045;
            if (b.alpha <= 0) levelUpBurst = null;
        }

        function drawDeathFlash() {
            if (deathFlashAlpha <= 0) return;
            ctx.save();
            ctx.globalAlpha = deathFlashAlpha;
            ctx.fillStyle = '#ff1111';
            ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            ctx.restore();
            deathFlashAlpha -= 0.06;
            if (deathFlashAlpha < 0) deathFlashAlpha = 0;
        }

        function draw() {
            drawBackground();
            drawParticles();
            drawRealisticSnake();
            drawRealisticFood();
            drawLevelUpBurst();
            drawDeathFlash();

            if (gameState === 'paused') {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
                ctx.fillStyle = '#7CFC00';
                ctx.font = 'bold 50px Segoe UI';
                ctx.textAlign = 'center';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                ctx.shadowBlur = 15;
                ctx.fillText('PAUSED', CANVAS_SIZE / 2, CANVAS_SIZE / 2);
                ctx.shadowBlur = 0;
            }
        }

        // ==================== IDLE ANIMATION ====================
        function startIdleAnimation() {
            if (idleAnimationId) return;

            let lastIdleTime = 0;

            function idleLoop(timestamp) {
                if (gameState === 'playing') {
                    idleAnimationId = null;
                    return;
                }

                if (timestamp - lastIdleTime >= IDLE_FRAME_INTERVAL) {
                    animationFrame++;
                    updateParticles();
                    draw();
                    lastIdleTime = timestamp;
                }

                idleAnimationId = requestAnimationFrame(idleLoop);
            }

            idleAnimationId = requestAnimationFrame(idleLoop);
        }

        function stopIdleAnimation() {
            if (idleAnimationId) {
                cancelAnimationFrame(idleAnimationId);
                idleAnimationId = null;
            }
        }

        // ==================== GAME CONTROLS ====================
        function startGame() {
            snake = [
                { x: 12, y: 12 },
                { x: 11, y: 12 },
                { x: 10, y: 12 }
            ];

            direction = { x: 1, y: 0 };
            nextDirection = { x: 1, y: 0 };
            score = 0;
            currentLevel = 1;
            gameState = 'playing';
            animationFrame = 0;
            lastUpdateTime = 0;
            accumulatedTime = 0;
            levelUpBurst = null;
            deathFlashAlpha = 0;
            jawAngle = 0;

            startScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';

            updateScore();
            updateLevel();
            generateVegetation();
            initParticles();
            spawnFood();

            stopIdleAnimation();

            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            animationId = requestAnimationFrame(gameLoop);
            announce('Game started');
        }

        function togglePause() {
            if (gameState === 'playing') {
                gameState = 'paused';
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
                draw();
                startIdleAnimation();
                announce('Game paused');
            } else if (gameState === 'paused') {
                gameState = 'playing';
                stopIdleAnimation();
                lastUpdateTime = 0;
                accumulatedTime = 0;
                animationId = requestAnimationFrame(gameLoop);
                announce('Game resumed');
            }
        }

        function resetGame() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            stopIdleAnimation();

            gameState = 'start';
            currentLevel = 1;
            startScreen.style.display = 'block';
            gameOverScreen.style.display = 'none';
            generateVegetation();
            initParticles();
            startIdleAnimation();
            announce('Game reset');
        }

        // ==================== EVENT HANDLERS ====================
        function handleKeydown(e) {
            if (e.code === 'Space') {
                e.preventDefault();
                if (gameState === 'start' || gameState === 'gameover') {
                    startGame();
                } else if (gameState === 'playing' || gameState === 'paused') {
                    togglePause();
                }
                return;
            }

            if (gameState !== 'playing') return;

            switch (e.key) {
                case 'ArrowUp':
                    e.preventDefault();
                    if (direction.y === 0) nextDirection = { x: 0, y: -1 };
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    if (direction.y === 0) nextDirection = { x: 0, y: 1 };
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    if (direction.x === 0) nextDirection = { x: -1, y: 0 };
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    if (direction.x === 0) nextDirection = { x: 1, y: 0 };
                    break;
            }
        }

        function handleTouchStart(e) {
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
        }

        function handleTouchEnd(e) {
            if (!touchStartX || !touchStartY) return;

            const touch = e.changedTouches[0];
            const deltaX = touch.clientX - touchStartX;
            const deltaY = touch.clientY - touchStartY;

            touchStartX = 0;
            touchStartY = 0;

            // Check if it's a tap (not a swipe)
            if (Math.abs(deltaX) < SWIPE_THRESHOLD && Math.abs(deltaY) < SWIPE_THRESHOLD) {
                if (gameState === 'start' || gameState === 'gameover') {
                    startGame();
                }
                return;
            }

            if (gameState !== 'playing') return;

            // Determine swipe direction
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                // Horizontal swipe
                if (deltaX > SWIPE_THRESHOLD && direction.x === 0) {
                    nextDirection = { x: 1, y: 0 };
                } else if (deltaX < -SWIPE_THRESHOLD && direction.x === 0) {
                    nextDirection = { x: -1, y: 0 };
                }
            } else {
                // Vertical swipe
                if (deltaY > SWIPE_THRESHOLD && direction.y === 0) {
                    nextDirection = { x: 0, y: 1 };
                } else if (deltaY < -SWIPE_THRESHOLD && direction.y === 0) {
                    nextDirection = { x: 0, y: -1 };
                }
            }
        }

        // Attach event listeners
        document.addEventListener('keydown', handleKeydown);
        canvas.addEventListener('touchstart', handleTouchStart, { passive: true });
        canvas.addEventListener('touchend', handleTouchEnd, { passive: true });

        startBtn.addEventListener('click', startGame);
        pauseBtn.addEventListener('click', togglePause);
        restartBtn.addEventListener('click', resetGame);

        // ==================== INITIAL SETUP ====================
        generateVegetation();
        initParticles();
        draw();
        startIdleAnimation();

    })();
    </script>
</body>
</html>
