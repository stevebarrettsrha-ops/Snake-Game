<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Serpent - Modern Snake Game</title>
    <meta name="description" content="Serpent – a modern, realistic Snake game with seasonal themes, animated food, and 10 levels of increasing challenge.">
    <meta property="og:title" content="Serpent – Modern Snake Game">
    <meta property="og:description" content="Play Serpent, a beautifully rendered Snake game with seasonal themes, animated food types, and 10 challenging levels.">
    <meta property="og:type" content="website">
    <meta name="theme-color" content="#0f2027">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 10px;
            box-sizing: border-box;
        }

        .game-container {
            background: linear-gradient(145deg, #1a1a1a, #2d2d2d);
            padding: 30px;
            border-radius: 25px;
            box-shadow:
                0 40px 80px rgba(0, 0, 0, 0.9),
                inset 0 2px 0 rgba(255, 255, 255, 0.1);
            border: 4px solid #444;
            max-width: 820px;
            width: 100%;
        }

        .game-wrapper {
            background: linear-gradient(135deg, #1e3c28 0%, #2d5a3d 100%);
            border: 12px solid #0a0a0a;
            border-radius: 15px;
            padding: 10px;
            box-shadow:
                inset 0 0 50px rgba(0, 0, 0, 0.6),
                0 10px 30px rgba(0, 0, 0, 0.7);
        }

        .info-bar {
            display: flex;
            justify-content: space-between;
            padding: 15px 20px;
            background: linear-gradient(180deg, rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.5));
            margin-bottom: 10px;
            font-weight: 600;
            color: #fff;
            font-size: 16px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
        }

        .info-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .label {
            font-size: 11px;
            opacity: 0.7;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .value {
            font-size: 20px;
            font-weight: bold;
            color: #7CFC00;
            text-shadow: 0 0 10px rgba(124, 252, 0, 0.5);
        }

        canvas {
            display: block;
            border-radius: 10px;
            box-shadow:
                inset 0 0 30px rgba(0, 0, 0, 0.3),
                0 10px 25px rgba(0, 0, 0, 0.6);
            touch-action: none;
        }

        .controls {
            margin-top: 30px;
            text-align: center;
            color: #fff;
        }

        .controls h3 {
            margin-bottom: 15px;
            text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.8);
            font-size: 22px;
            letter-spacing: 2px;
        }

        .controls p {
            margin: 8px 0;
            font-size: 14px;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.6);
            opacity: 0.9;
        }

        .button-container {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 20px;
        }

        button {
            padding: 16px 32px;
            background: linear-gradient(135deg, #7CFC00, #32CD32);
            border: none;
            border-radius: 12px;
            color: #000;
            font-family: 'Segoe UI', sans-serif;
            font-weight: bold;
            cursor: pointer;
            font-size: 15px;
            transition: all 0.3s ease;
            box-shadow:
                0 8px 16px rgba(124, 252, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        button:hover {
            background: linear-gradient(135deg, #90FF10, #40E040);
            transform: translateY(-4px) scale(1.05);
            box-shadow:
                0 12px 24px rgba(124, 252, 0, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.4);
        }

        button:active {
            transform: translateY(-2px) scale(1.02);
        }

        button:focus {
            outline: 3px solid #7CFC00;
            outline-offset: 2px;
        }

        .overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(20, 40, 20, 0.95));
            padding: 40px 50px;
            border-radius: 20px;
            text-align: center;
            color: #fff;
            display: none;
            border: 4px solid #7CFC00;
            box-shadow:
                0 20px 60px rgba(0, 0, 0, 0.9),
                inset 0 2px 0 rgba(124, 252, 0, 0.2);
            backdrop-filter: blur(10px);
        }

        .overlay h2 {
            margin-bottom: 20px;
            font-size: 42px;
            text-shadow:
                2px 2px 4px rgba(0, 0, 0, 0.8),
                0 0 20px rgba(124, 252, 0, 0.6);
            color: #7CFC00;
        }

        .overlay p {
            margin: 15px 0;
            font-size: 18px;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.8);
        }

        .legend {
            margin-top: 25px;
            background: rgba(0, 0, 0, 0.5);
            padding: 15px;
            border-radius: 12px;
            font-size: 14px;
            border: 2px solid rgba(124, 252, 0, 0.3);
        }

        .legend-item {
            margin: 8px 0;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .pulsing {
            animation: pulse 2s infinite;
        }

        @keyframes scorePop {
            0%   { transform: scale(1);    color: #7CFC00; }
            40%  { transform: scale(1.45); color: #ffffff; text-shadow: 0 0 18px #fff, 0 0 8px #7CFC00; }
            100% { transform: scale(1);    color: #7CFC00; }
        }

        .score-pop {
            animation: scorePop 0.35s ease-out;
        }

        @keyframes levelFlash {
            0%   { background: rgba(124,252,0,0.18); }
            100% { background: transparent; }
        }

        .level-flash {
            animation: levelFlash 0.6s ease-out;
        }

        .sr-only {
            position: absolute;
            width: 1px;
            height: 1px;
            padding: 0;
            margin: -1px;
            overflow: hidden;
            clip: rect(0, 0, 0, 0);
            white-space: nowrap;
            border: 0;
        }

        /* ---- Mobile responsive scaling ---- */
        @media (max-width: 780px) {
            body {
                align-items: flex-start;
                padding: 10px;
            }
            .game-container {
                padding: 12px;
                border-radius: 15px;
            }
            .game-wrapper {
                border-width: 6px;
                padding: 4px;
            }
            canvas {
                width: 100% !important;
                height: auto !important;
            }
            .info-bar {
                padding: 8px 12px;
                font-size: 13px;
            }
            .value {
                font-size: 16px;
            }
            .button-container {
                flex-wrap: wrap;
            }
            button {
                padding: 12px 18px;
                font-size: 13px;
            }
            .overlay {
                padding: 24px 28px;
                width: 90%;
            }
            .overlay h2 {
                font-size: 30px;
            }
        }
    </style>
</head>
<body>
    <div class="game-container" role="main" aria-label="Snake Game">
        <div class="game-wrapper">
            <div class="info-bar" role="status" aria-live="polite">
                <div class="info-item">
                    <span class="label" id="score-label">Score</span>
                    <span class="value" id="score" aria-labelledby="score-label">0</span>
                </div>
                <div class="info-item">
                    <span class="label" id="level-label">Level</span>
                    <span class="value" id="level" aria-labelledby="level-label">1</span>
                </div>
                <div class="info-item">
                    <span class="label" id="highscore-label">High Score</span>
                    <span class="value" id="highScore" aria-labelledby="highscore-label">0</span>
                </div>
            </div>
            <canvas id="gameCanvas" width="700" height="700" aria-label="Game canvas - use arrow keys to control the snake" tabindex="0"></canvas>

            <div class="overlay" id="startScreen" role="dialog" aria-labelledby="start-title">
                <h2 id="start-title">SERPENT</h2>
                <p style="font-size: 16px; opacity: 0.8;">Modern Realistic Snake Game</p>
                <p style="margin-top: 25px;">Press SPACE or tap START to begin</p>
                <div class="legend">
                    <div class="legend-item">Rabbit: 50 points (Rare, Animated)</div>
                    <div class="legend-item">Mouse: 20 points (Common)</div>
                    <div class="legend-item">Apple: 10 points (Common)</div>
                </div>
            </div>

            <div class="overlay" id="gameOverScreen" role="dialog" aria-labelledby="gameover-title">
                <h2 id="gameover-title">GAME OVER</h2>
                <p>Final Score: <span id="finalScore">0</span></p>
                <p>Level Reached: <span id="finalLevel">1</span></p>
                <p style="margin-top: 25px;" class="pulsing">Press SPACE or tap RESTART</p>
            </div>
        </div>

        <div class="controls">
            <h3>CONTROLS</h3>
            <p>Arrow Keys / Swipe - Move Snake</p>
            <p>SPACE - Start / Pause / Resume</p>
            <div class="button-container">
                <button id="startBtn" aria-label="Start game">START</button>
                <button id="pauseBtn" aria-label="Pause game">PAUSE</button>
                <button id="restartBtn" aria-label="Restart game">RESTART</button>
            </div>
        </div>
        <div class="sr-only" id="game-announcer" aria-live="assertive"></div>
    </div>

    <script>
    'use strict';

    (function() {
        // ==================== CONSTANTS ====================
        const CANVAS_SIZE = 700;
        const GRID_SIZE = 25;
        const TILE_SIZE = CANVAS_SIZE / GRID_SIZE;
        const GRASS_COUNT = 400;
        const SHRUB_COUNT = 25;
        const SHRUB_EDGE_MARGIN = 80;
        const PARTICLE_COUNT = 40;
        const LIGHT_PATCH_COUNT = 5;
        const MAX_FOOD_SPAWN_ATTEMPTS = 100;
        const IDLE_FRAME_INTERVAL = 50;

        const FOOD_TYPES = {
            APPLE: { points: 10, probability: 0.6 },
            MOUSE: { points: 20, probability: 0.3 },
            RABBIT: { points: 50, probability: 0.1 }
        };

        const LEVELS = [
            { level: 1, speed: 140, pointsNeeded: 100, season: 'spring' },
            { level: 2, speed: 125, pointsNeeded: 250, season: 'summer' },
            { level: 3, speed: 110, pointsNeeded: 400, season: 'autumn' },
            { level: 4, speed: 95, pointsNeeded: 600, season: 'winter' },
            { level: 5, speed: 80, pointsNeeded: 850, season: 'spring' },
            { level: 6, speed: 70, pointsNeeded: 1150, season: 'summer' },
            { level: 7, speed: 60, pointsNeeded: 1500, season: 'autumn' },
            { level: 8, speed: 50, pointsNeeded: 1900, season: 'winter' },
            { level: 9, speed: 40, pointsNeeded: 2400, season: 'mystic' },
            { level: 10, speed: 30, pointsNeeded: Infinity, season: 'void' }
        ];

        const SEASONS = {
            spring: {
                ground: ['#7cb342', '#8bc34a', '#9ccc65'],
                grass: '#4caf50',
                accent: '#66bb6a',
                particle: '#ffb6c1'
            },
            summer: {
                ground: ['#9ccc65', '#aed581', '#c5e1a5'],
                grass: '#7cb342',
                accent: '#8bc34a',
                particle: '#ffd54f'
            },
            autumn: {
                ground: ['#a1887f', '#bcaaa4', '#d7ccc8'],
                grass: '#8d6e63',
                accent: '#a1887f',
                particle: '#ff8a65'
            },
            winter: {
                ground: ['#cfd8dc', '#eceff1', '#ffffff'],
                grass: '#b0bec5',
                accent: '#cfd8dc',
                particle: '#e1f5fe'
            },
            mystic: {
                ground: ['#4db6ac', '#26a69a', '#009688'],
                grass: '#00897b',
                accent: '#26a69a',
                particle: '#00e5ff'
            },
            void: {
                ground: ['#424242', '#616161', '#757575'],
                grass: '#212121',
                accent: '#424242',
                particle: '#9e9e9e'
            }
        };

        // ==================== DOM ELEMENTS ====================
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Canvas context fallback check
        if (!ctx) {
            document.body.innerHTML = '<p style="color: white; text-align: center; margin-top: 50px;">Your browser does not support HTML5 Canvas. Please use a modern browser.</p>';
            return;
        }

        // Handle GPU/context loss (e.g. low memory, tab switching on mobile)
        canvas.addEventListener('contextlost', function(e) {
            e.preventDefault();
            if (animationId) { cancelAnimationFrame(animationId); animationId = null; }
            if (idleAnimationId) { cancelAnimationFrame(idleAnimationId); idleAnimationId = null; }
            announce('Display connection lost. Please wait...');
        }, false);

        canvas.addEventListener('contextrestored', function() {
            preRenderBackground();
            draw();
            if (gameState !== 'playing') startIdleAnimation();
            announce('Display restored.');
        }, false);

        const scoreEl = document.getElementById('score');
        const levelEl = document.getElementById('level');
        const highScoreEl = document.getElementById('highScore');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const finalScoreEl = document.getElementById('finalScore');
        const finalLevelEl = document.getElementById('finalLevel');
        const startBtn = document.getElementById('startBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const restartBtn = document.getElementById('restartBtn');
        const announcer = document.getElementById('game-announcer');

        // Offscreen canvas for pre-rendered background
        const bgCanvas = document.createElement('canvas');
        bgCanvas.width = CANVAS_SIZE;
        bgCanvas.height = CANVAS_SIZE;
        const bgCtx = bgCanvas.getContext('2d');

        // ==================== VISUAL EFFECT STATE ====================
        let levelUpBurst = null;   // { x, y, radius, maxRadius, alpha }
        let deathFlashAlpha = 0;   // 0–1, drives the red overlay on death

        // ==================== GAME STATE ====================
        let snake = [];
        let direction = { x: 1, y: 0 };
        let nextDirection = { x: 1, y: 0 };
        let food = {};
        let score = 0;
        function loadHighScore() {
            try {
                return parseInt(localStorage.getItem('serpentHighScore'), 10) || 0;
            } catch (e) {
                return 0;
            }
        }
        function saveHighScore(val) {
            try {
                localStorage.setItem('serpentHighScore', val);
            } catch (e) { /* quota exceeded or private/incognito mode */ }
        }
        let highScore = loadHighScore();
        let currentLevel = 1;
        let gameState = 'start'; // 'start', 'playing', 'paused', 'gameover'
        let animationFrame = 0;
        let particles = [];
        let shrubs = [];
        let lastUpdateTime = 0;
        let accumulatedTime = 0;
        let animationId = null;
        let idleAnimationId = null;

        // Touch handling state
        let touchStartX = 0;
        let touchStartY = 0;
        const SWIPE_THRESHOLD = 30;

        // ==================== INITIALIZATION ====================
        highScoreEl.textContent = highScore;
        startScreen.style.display = 'block';

        // ==================== UTILITY FUNCTIONS ====================
        function shadeColor(color, percent) {
            const num = parseInt(color.replace('#', ''), 16);
            const amt = Math.round(2.55 * percent);
            const R = Math.max(0, Math.min(255, (num >> 16) + amt));
            const G = Math.max(0, Math.min(255, ((num >> 8) & 0x00FF) + amt));
            const B = Math.max(0, Math.min(255, (num & 0x0000FF) + amt));
            return '#' + (0x1000000 + R * 0x10000 + G * 0x100 + B).toString(16).slice(1);
        }

        function getSeasonColors(season) {
            return SEASONS[season] || SEASONS.spring;
        }

        function announce(message) {
            announcer.textContent = message;
        }

        // ==================== VEGETATION GENERATION ====================
        function generateVegetation() {
            shrubs = [];
            const colors = getSeasonColors(LEVELS[currentLevel - 1].season);
            const season = LEVELS[currentLevel - 1].season;

            for (let i = 0; i < SHRUB_COUNT; i++) {
                const edge = Math.floor(Math.random() * 4);
                let x, y;

                if (edge === 0) {
                    x = Math.random() * CANVAS_SIZE;
                    y = Math.random() * SHRUB_EDGE_MARGIN;
                } else if (edge === 1) {
                    x = CANVAS_SIZE - SHRUB_EDGE_MARGIN + Math.random() * SHRUB_EDGE_MARGIN;
                    y = Math.random() * CANVAS_SIZE;
                } else if (edge === 2) {
                    x = Math.random() * CANVAS_SIZE;
                    y = CANVAS_SIZE - SHRUB_EDGE_MARGIN + Math.random() * SHRUB_EDGE_MARGIN;
                } else {
                    x = Math.random() * SHRUB_EDGE_MARGIN;
                    y = Math.random() * CANVAS_SIZE;
                }

                let shrubColor = colors.grass;
                if (season === 'autumn') {
                    shrubColor = Math.random() > 0.5 ? '#8b4513' : colors.grass;
                } else if (season === 'winter') {
                    shrubColor = '#7a9a7a';
                }

                const circles = [];
                for (let j = 0; j < 6; j++) {
                    const offsetX = (Math.random() - 0.5) * 30 * 0.6;
                    const offsetY = (Math.random() - 0.5) * 30 * 0.4;
                    const size = 30 * 0.3 + Math.random() * 30 * 0.3;
                    circles.push({ offsetX, offsetY, size });
                }

                shrubs.push({
                    x: x,
                    y: y,
                    size: 25 + Math.random() * 30,
                    color: shrubColor,
                    circles: circles
                });
            }

            // Pre-render background after generating vegetation
            preRenderBackground();
        }

        // ==================== PRE-RENDERED BACKGROUND ====================
        function preRenderBackground() {
            const colors = getSeasonColors(LEVELS[currentLevel - 1].season);

            // Clear background canvas
            bgCtx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

            // Radial gradient for depth
            const gradient = bgCtx.createRadialGradient(
                CANVAS_SIZE / 2, CANVAS_SIZE / 2, 0,
                CANVAS_SIZE / 2, CANVAS_SIZE / 2, CANVAS_SIZE / 1.3
            );
            gradient.addColorStop(0, colors.ground[1]);
            gradient.addColorStop(0.7, colors.ground[0]);
            gradient.addColorStop(1, colors.ground[0]);
            bgCtx.fillStyle = gradient;
            bgCtx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);

            // Pre-render grass with fixed positions (seeded by level)
            const grassPositions = [];
            const seed = currentLevel * 12345;
            for (let i = 0; i < GRASS_COUNT; i++) {
                const pseudoRandom1 = ((seed + i * 7919) % 10000) / 10000;
                const pseudoRandom2 = ((seed + i * 7927) % 10000) / 10000;
                const pseudoRandom3 = ((seed + i * 7933) % 10000) / 10000;
                const pseudoRandom4 = ((seed + i * 7937) % 10000) / 10000;

                grassPositions.push({
                    x: pseudoRandom1 * CANVAS_SIZE,
                    y: pseudoRandom2 * CANVAS_SIZE,
                    length: 8 + pseudoRandom3 * 12,
                    angle: pseudoRandom4 * Math.PI * 2
                });
            }

            grassPositions.forEach(grass => {
                bgCtx.save();
                bgCtx.translate(grass.x, grass.y);
                bgCtx.rotate(grass.angle);

                const grassGradient = bgCtx.createLinearGradient(0, 0, 0, grass.length);
                grassGradient.addColorStop(0, colors.grass);
                grassGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

                bgCtx.strokeStyle = grassGradient;
                bgCtx.lineWidth = 1.5;
                bgCtx.lineCap = 'round';
                bgCtx.globalAlpha = 0.3;
                bgCtx.beginPath();
                bgCtx.moveTo(0, 0);
                bgCtx.lineTo(0, grass.length);
                bgCtx.stroke();
                bgCtx.restore();
            });

            // Pre-render shrubs
            shrubs.forEach(shrub => {
                // Shadow
                bgCtx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                bgCtx.beginPath();
                bgCtx.ellipse(shrub.x, shrub.y + shrub.size * 0.3, shrub.size * 0.7, shrub.size * 0.15, 0, 0, Math.PI * 2);
                bgCtx.fill();

                shrub.circles.forEach(circle => {
                    const circleGradient = bgCtx.createRadialGradient(
                        shrub.x + circle.offsetX - circle.size * 0.3,
                        shrub.y + circle.offsetY - circle.size * 0.3,
                        0,
                        shrub.x + circle.offsetX,
                        shrub.y + circle.offsetY,
                        circle.size
                    );
                    circleGradient.addColorStop(0, shrub.color);
                    circleGradient.addColorStop(1, shadeColor(shrub.color, -35));

                    bgCtx.fillStyle = circleGradient;
                    bgCtx.beginPath();
                    bgCtx.arc(shrub.x + circle.offsetX, shrub.y + circle.offsetY, circle.size, 0, Math.PI * 2);
                    bgCtx.fill();
                });
            });

            // Pre-render light patches with fixed positions
            for (let i = 0; i < LIGHT_PATCH_COUNT; i++) {
                const pseudoRandom1 = ((currentLevel * 54321 + i * 7919) % 10000) / 10000;
                const pseudoRandom2 = ((currentLevel * 54321 + i * 7927) % 10000) / 10000;
                const pseudoRandom3 = ((currentLevel * 54321 + i * 7933) % 10000) / 10000;

                const x = pseudoRandom1 * CANVAS_SIZE;
                const y = pseudoRandom2 * CANVAS_SIZE;
                const size = 100 + pseudoRandom3 * 200;

                const lightGradient = bgCtx.createRadialGradient(x, y, 0, x, y, size);
                lightGradient.addColorStop(0, 'rgba(255, 255, 255, 0.05)');
                lightGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

                bgCtx.fillStyle = lightGradient;
                bgCtx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            }
        }

        function drawBackground() {
            // Simply draw the pre-rendered background
            ctx.drawImage(bgCanvas, 0, 0);
        }

        // ==================== PARTICLES ====================
        function initParticles() {
            particles = [];
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                particles.push({
                    x: Math.random() * CANVAS_SIZE,
                    y: Math.random() * CANVAS_SIZE,
                    vx: (Math.random() - 0.5) * 0.5,
                    vy: 0.3 + Math.random() * 0.7,
                    size: 2 + Math.random() * 4,
                    opacity: 0.3 + Math.random() * 0.5,
                    rotation: Math.random() * Math.PI * 2,
                    rotationSpeed: (Math.random() - 0.5) * 0.05
                });
            }
        }

        function updateParticles() {
            particles.forEach(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.rotation += p.rotationSpeed;

                if (p.y > CANVAS_SIZE) {
                    p.y = -10;
                    p.x = Math.random() * CANVAS_SIZE;
                }
                if (p.x < -10) p.x = CANVAS_SIZE + 10;
                if (p.x > CANVAS_SIZE + 10) p.x = -10;
            });
        }

        // Cache a small offscreen canvas per season color to stamp particles cheaply
        const particleCache = {};
        function getParticleStamp(color, maxSize) {
            const key = color + maxSize;
            if (particleCache[key]) return particleCache[key];
            const size = Math.ceil(maxSize) * 2 + 2;
            const stamp = document.createElement('canvas');
            stamp.width = size;
            stamp.height = size;
            const sc = stamp.getContext('2d');
            const cx = size / 2;
            const grad = sc.createRadialGradient(cx, cx, 0, cx, cx, maxSize);
            grad.addColorStop(0, color);
            grad.addColorStop(1, 'rgba(255,255,255,0)');
            sc.fillStyle = grad;
            sc.beginPath();
            sc.arc(cx, cx, maxSize, 0, Math.PI * 2);
            sc.fill();
            particleCache[key] = stamp;
            return stamp;
        }

        function drawParticles() {
            const colors = getSeasonColors(LEVELS[currentLevel - 1].season);

            particles.forEach(p => {
                const stamp = getParticleStamp(colors.particle, p.size);
                const half = stamp.width / 2;
                ctx.save();
                ctx.globalAlpha = p.opacity;
                ctx.translate(p.x, p.y);
                ctx.rotate(p.rotation);
                ctx.drawImage(stamp, -half, -half);
                ctx.restore();
            });
        }

        // ==================== SNAKE RENDERING ====================
        function drawRealisticSnake() {
            if (snake.length === 0) return;

            const screenSegments = snake.map(s => ({
                x: s.x * TILE_SIZE + TILE_SIZE / 2,
                y: s.y * TILE_SIZE + TILE_SIZE / 2,
                gridX: s.x,
                gridY: s.y
            }));

            const continuousSegments = [];
            const segmentStartIndices = [];
            let currentSegment = [screenSegments[0]];
            let currentStartIndex = 0;

            for (let i = 1; i < screenSegments.length; i++) {
                const prev = snake[i - 1];
                const curr = snake[i];

                const wrapsHorizontal = Math.abs(prev.x - curr.x) > GRID_SIZE / 2;
                const wrapsVertical = Math.abs(prev.y - curr.y) > GRID_SIZE / 2;

                if (wrapsHorizontal || wrapsVertical) {
                    segmentStartIndices.push(currentStartIndex);
                    continuousSegments.push(currentSegment);
                    currentStartIndex = i;
                    currentSegment = [screenSegments[i]];
                } else {
                    currentSegment.push(screenSegments[i]);
                }
            }
            segmentStartIndices.push(currentStartIndex);
            continuousSegments.push(currentSegment);

            continuousSegments.forEach((segment, segIndex) => {
                if (segment.length === 0) return;
                const globalOffset = segmentStartIndices[segIndex];

                // Draw shadow
                ctx.save();
                ctx.globalAlpha = 0.3;
                segment.forEach((point, i) => {
                    const globalIndex = globalOffset + i;
                    const size = (TILE_SIZE / 2.2) * (1 - globalIndex / snake.length * 0.4);

                    const shadowGradient = ctx.createRadialGradient(
                        point.x + 6, point.y + 6, 0,
                        point.x + 6, point.y + 6, size + 4
                    );
                    shadowGradient.addColorStop(0, 'rgba(0, 0, 0, 0.5)');
                    shadowGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');

                    ctx.fillStyle = shadowGradient;
                    ctx.beginPath();
                    ctx.arc(point.x + 6, point.y + 6, size + 4, 0, Math.PI * 2);
                    ctx.fill();
                });
                ctx.restore();

                // Draw body outline
                if (segment.length > 1) {
                    ctx.save();
                    ctx.strokeStyle = '#0d2b0d';
                    ctx.lineWidth = TILE_SIZE + 6;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';

                    ctx.beginPath();
                    ctx.moveTo(segment[0].x, segment[0].y);

                    for (let i = 1; i < segment.length; i++) {
                        const xc = (segment[i].x + segment[i - 1].x) / 2;
                        const yc = (segment[i].y + segment[i - 1].y) / 2;
                        ctx.quadraticCurveTo(segment[i - 1].x, segment[i - 1].y, xc, yc);
                    }
                    ctx.lineTo(segment[segment.length - 1].x, segment[segment.length - 1].y);
                    ctx.stroke();
                    ctx.restore();
                }

                // Draw main body
                if (segment.length > 1) {
                    ctx.save();
                    ctx.lineWidth = TILE_SIZE;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';

                    ctx.beginPath();
                    ctx.moveTo(segment[0].x, segment[0].y);

                    for (let i = 1; i < segment.length; i++) {
                        const xc = (segment[i].x + segment[i - 1].x) / 2;
                        const yc = (segment[i].y + segment[i - 1].y) / 2;
                        ctx.quadraticCurveTo(segment[i - 1].x, segment[i - 1].y, xc, yc);
                    }
                    ctx.lineTo(segment[segment.length - 1].x, segment[segment.length - 1].y);

                    const bodyGradient = ctx.createLinearGradient(
                        0, segment[0].y - TILE_SIZE / 2,
                        0, segment[0].y + TILE_SIZE / 2
                    );
                    bodyGradient.addColorStop(0, '#2d5a2d');
                    bodyGradient.addColorStop(0.3, '#3d7a3d');
                    bodyGradient.addColorStop(0.5, '#4a8a4a');
                    bodyGradient.addColorStop(0.7, '#3d7a3d');
                    bodyGradient.addColorStop(1, '#2d5a2d');

                    ctx.strokeStyle = bodyGradient;
                    ctx.stroke();
                    ctx.restore();
                }

                // Draw scales
                segment.forEach((point, i) => {
                    const globalIndex = globalOffset + i;
                    const size = (TILE_SIZE / 2.2) * (1 - globalIndex / snake.length * 0.4);

                    ctx.save();
                    ctx.globalAlpha = 0.6;

                    // Dorsal scales
                    for (let row = 0; row < 3; row++) {
                        const scaleY = point.y - size * 0.3 + row * size * 0.3;

                        ctx.fillStyle = row === 1 ? '#1a3a1a' : '#2d5a2d';
                        ctx.beginPath();
                        ctx.moveTo(point.x - 3, scaleY);
                        ctx.lineTo(point.x, scaleY - 3);
                        ctx.lineTo(point.x + 3, scaleY);
                        ctx.lineTo(point.x, scaleY + 3);
                        ctx.closePath();
                        ctx.fill();
                    }

                    // Lateral scales
                    ctx.globalAlpha = 0.4;
                    for (let side = 0; side < 2; side++) {
                        const sideX = point.x + (side === 0 ? -size * 0.7 : size * 0.7);
                        for (let j = 0; j < 4; j++) {
                            const scaleY = point.y - size * 0.5 + j * size * 0.3;

                            ctx.fillStyle = '#4a8a4a';
                            ctx.beginPath();
                            ctx.ellipse(sideX, scaleY, 4, 3, 0, 0, Math.PI * 2);
                            ctx.fill();

                            ctx.fillStyle = 'rgba(139, 195, 74, 0.3)';
                            ctx.beginPath();
                            ctx.ellipse(sideX - 1, scaleY - 1, 2, 1.5, 0, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }

                    // Ventral scales
                    ctx.globalAlpha = 0.5;
                    const bellyWidth = size * 1.2;
                    for (let j = 0; j < 5; j++) {
                        const scaleX = point.x - bellyWidth / 2 + j * bellyWidth / 4;

                        ctx.fillStyle = '#7cb77c';
                        ctx.fillRect(scaleX, point.y + size * 0.6, bellyWidth / 5, 3);

                        ctx.fillStyle = 'rgba(200, 230, 201, 0.4)';
                        ctx.fillRect(scaleX, point.y + size * 0.6, bellyWidth / 5, 1);
                    }

                    ctx.restore();
                });
            });

            // Draw head
            const head = screenSegments[0];
            const headSize = TILE_SIZE / 1.6;
            const neckSize = TILE_SIZE / 2;

            let headAngle;
            if (screenSegments.length > 1) {
                const neck = screenSegments[1];
                headAngle = Math.atan2(head.y - neck.y, head.x - neck.x);
            } else {
                headAngle = Math.atan2(direction.y, direction.x);
            }

            ctx.save();
            ctx.translate(head.x, head.y);
            ctx.rotate(headAngle);

            // Head glow
            const headGlowRadius = headSize * 1.5;
            const headGlow = ctx.createRadialGradient(0, 0, headSize * 0.4, 0, 0, headGlowRadius);
            headGlow.addColorStop(0, 'rgba(90, 200, 90, 0.22)');
            headGlow.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = headGlow;
            ctx.beginPath();
            ctx.arc(0, 0, headGlowRadius, 0, Math.PI * 2);
            ctx.fill();

            // Head shadow
            ctx.globalAlpha = 0.4;
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.ellipse(8, 4, headSize, neckSize, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;

            // Neck
            const neckGradient = ctx.createRadialGradient(-neckSize, 0, 0, 0, 0, neckSize);
            neckGradient.addColorStop(0, '#3d7a3d');
            neckGradient.addColorStop(0.6, '#2d5a2d');
            neckGradient.addColorStop(1, '#1a3a1a');

            ctx.fillStyle = neckGradient;
            ctx.beginPath();
            ctx.ellipse(-neckSize / 2, 0, neckSize, neckSize * 0.9, 0, 0, Math.PI * 2);
            ctx.fill();

            // Head
            const headGradient = ctx.createRadialGradient(headSize / 3, -2, 0, headSize / 2, 0, headSize);
            headGradient.addColorStop(0, '#5a9a5a');
            headGradient.addColorStop(0.4, '#3d7a3d');
            headGradient.addColorStop(0.7, '#2d5a2d');
            headGradient.addColorStop(1, '#1a3a1a');

            ctx.fillStyle = headGradient;
            ctx.beginPath();
            ctx.ellipse(headSize / 2, 0, headSize * 0.7, neckSize * 0.85, 0, 0, Math.PI * 2);
            ctx.fill();

            // Snout
            ctx.fillStyle = '#4a8a4a';
            ctx.beginPath();
            ctx.ellipse(headSize, 0, headSize * 0.35, neckSize * 0.6, 0, 0, Math.PI * 2);
            ctx.fill();

            // Nostrils
            ctx.fillStyle = '#1a3a1a';
            ctx.beginPath();
            ctx.ellipse(headSize + 8, -3, 2, 1.5, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(headSize + 8, 3, 2, 1.5, 0, 0, Math.PI * 2);
            ctx.fill();

            // Eyes
            const eyeY = neckSize * 0.5;
            const eyeSize = 6;

            // Left eye
            ctx.fillStyle = '#ffd700';
            ctx.beginPath();
            ctx.ellipse(headSize * 0.4, -eyeY, eyeSize, eyeSize * 0.8, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#000';
            ctx.fillRect(headSize * 0.4 - 1.5, -eyeY - 4, 3, 8);

            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.beginPath();
            ctx.arc(headSize * 0.4 - 2, -eyeY - 2, 2, 0, Math.PI * 2);
            ctx.fill();

            // Right eye
            ctx.fillStyle = '#ffd700';
            ctx.beginPath();
            ctx.ellipse(headSize * 0.4, eyeY, eyeSize, eyeSize * 0.8, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#000';
            ctx.fillRect(headSize * 0.4 - 1.5, eyeY - 4, 3, 8);

            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.beginPath();
            ctx.arc(headSize * 0.4 - 2, eyeY - 2, 2, 0, Math.PI * 2);
            ctx.fill();

            // Head scales
            ctx.globalAlpha = 0.3;
            for (let i = 0; i < 8; i++) {
                const scaleX = headSize * 0.2 + (i % 4) * 6;
                const scaleY = (i < 4 ? -1 : 1) * (neckSize * 0.3);

                ctx.fillStyle = '#2d5a2d';
                ctx.beginPath();
                ctx.ellipse(scaleX, scaleY, 4, 3, 0, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            // Tongue (when near food)
            if (food.x !== undefined && food.y !== undefined) {
                if (Math.abs(snake[0].x - food.x) + Math.abs(snake[0].y - food.y) <= 2) {
                    const tongueLength = 18 + Math.sin(animationFrame * 0.3) * 6;
                    const tongueX = headSize + 10;

                    ctx.strokeStyle = '#c41e3a';
                    ctx.lineWidth = 2.5;
                    ctx.lineCap = 'round';

                    ctx.beginPath();
                    ctx.moveTo(headSize + 5, 0);
                    ctx.lineTo(tongueX + tongueLength, 0);
                    ctx.stroke();

                    const forkLength = 6;
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo(tongueX + tongueLength, 0);
                    ctx.lineTo(tongueX + tongueLength + forkLength, -4);
                    ctx.moveTo(tongueX + tongueLength, 0);
                    ctx.lineTo(tongueX + tongueLength + forkLength, 4);
                    ctx.stroke();
                }
            }

            ctx.restore();
        }

        // ==================== FOOD RENDERING ====================
        function drawFoodGlow(fx, fy, r, g, b, baseRadius) {
            // Breathing glow ring around food
            const pulse = 0.5 + 0.5 * Math.sin(animationFrame * 0.12);
            const glowRadius = baseRadius + 6 + pulse * 8;
            const innerAlpha = 0.35 + pulse * 0.2;
            const glowGrad = ctx.createRadialGradient(fx, fy, baseRadius * 0.6, fx, fy, glowRadius);
            glowGrad.addColorStop(0, `rgba(${r},${g},${b},${innerAlpha.toFixed(2)})`);
            glowGrad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = glowGrad;
            ctx.beginPath();
            ctx.arc(fx, fy, glowRadius, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawRealisticFood() {
            if (food.x === undefined || food.y === undefined) return;

            const fx = food.x * TILE_SIZE + TILE_SIZE / 2;
            const fy = food.y * TILE_SIZE + TILE_SIZE / 2;

            if (food.type === 'RABBIT') {
                drawFoodGlow(fx, fy, 240, 240, 200, 16);
                const hop = Math.abs(Math.sin(animationFrame * 0.15)) * 15;
                const ry = fy - hop;

                // Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(fx, fy + 2, 18, 8, 0, 0, Math.PI * 2);
                ctx.fill();

                // Body
                const bodyGradient = ctx.createRadialGradient(fx - 5, ry - 5, 0, fx, ry, 15);
                bodyGradient.addColorStop(0, '#f5f5f5');
                bodyGradient.addColorStop(1, '#d0d0d0');
                ctx.fillStyle = bodyGradient;
                ctx.beginPath();
                ctx.ellipse(fx, ry, 16, 20, 0, 0, Math.PI * 2);
                ctx.fill();

                // Head
                ctx.beginPath();
                ctx.ellipse(fx, ry - 15, 12, 14, 0, 0, Math.PI * 2);
                ctx.fill();

                // Ears
                ctx.fillStyle = '#e8e8e8';
                ctx.beginPath();
                ctx.ellipse(fx - 6, ry - 25, 4, 12, -0.2, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(fx + 6, ry - 25, 4, 12, 0.2, 0, Math.PI * 2);
                ctx.fill();

                // Nose
                ctx.fillStyle = '#ffb6c1';
                ctx.beginPath();
                ctx.arc(fx, ry - 14, 1.5, 0, Math.PI * 2);
                ctx.fill();

                // Tail
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(fx - 12, ry + 8, 5, 0, Math.PI * 2);
                ctx.fill();

            } else if (food.type === 'MOUSE') {
                drawFoodGlow(fx, fy, 160, 160, 160, 12);
                // Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(fx, fy + 2, 15, 6, 0, 0, Math.PI * 2);
                ctx.fill();

                // Body
                const mouseGradient = ctx.createRadialGradient(fx - 3, fy - 3, 0, fx, fy, 12);
                mouseGradient.addColorStop(0, '#9e9e9e');
                mouseGradient.addColorStop(1, '#616161');
                ctx.fillStyle = mouseGradient;
                ctx.beginPath();
                ctx.ellipse(fx, fy, 14, 10, 0, 0, Math.PI * 2);
                ctx.fill();

                // Head
                ctx.beginPath();
                ctx.ellipse(fx - 10, fy, 8, 9, 0, 0, Math.PI * 2);
                ctx.fill();

                // Ear
                ctx.fillStyle = '#757575';
                ctx.beginPath();
                ctx.arc(fx - 12, fy - 6, 4, 0, Math.PI * 2);
                ctx.fill();

                // Eye
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(fx - 13, fy - 1, 1.5, 0, Math.PI * 2);
                ctx.fill();

                // Tail
                ctx.strokeStyle = '#757575';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(fx + 14, fy);
                ctx.quadraticCurveTo(fx + 20, fy - 5, fx + 25, fy);
                ctx.stroke();

            } else {
                // Apple
                drawFoodGlow(fx, fy, 229, 57, 53, 13);
                // Shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.beginPath();
                ctx.ellipse(fx, fy + 3, 12, 5, 0, 0, Math.PI * 2);
                ctx.fill();

                // Apple body
                const appleGradient = ctx.createRadialGradient(fx - 5, fy - 5, 0, fx, fy, 14);
                appleGradient.addColorStop(0, '#ff6b6b');
                appleGradient.addColorStop(0.6, '#e53935');
                appleGradient.addColorStop(1, '#c62828');
                ctx.fillStyle = appleGradient;
                ctx.beginPath();
                ctx.arc(fx, fy, 13, 0, Math.PI * 2);
                ctx.fill();

                // Top indent
                ctx.fillStyle = '#c62828';
                ctx.beginPath();
                ctx.arc(fx, fy - 10, 4, 0, Math.PI * 2);
                ctx.fill();

                // Highlight
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.beginPath();
                ctx.arc(fx - 5, fy - 6, 5, 0, Math.PI * 2);
                ctx.fill();

                // Stem
                ctx.strokeStyle = '#5d4037';
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(fx, fy - 13);
                ctx.lineTo(fx + 2, fy - 18);
                ctx.stroke();

                // Leaf
                ctx.fillStyle = '#7cb342';
                ctx.beginPath();
                ctx.ellipse(fx + 5, fy - 16, 5, 3, 0.5, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // ==================== GAME LOGIC ====================
        function spawnFood() {
            // Clear probability-based food selection
            // APPLE: 60%, MOUSE: 30%, RABBIT: 10%
            const rand = Math.random();
            let type;

            if (rand < FOOD_TYPES.RABBIT.probability) {
                // 0 to 0.1 (10%)
                type = 'RABBIT';
            } else if (rand < FOOD_TYPES.RABBIT.probability + FOOD_TYPES.MOUSE.probability) {
                // 0.1 to 0.4 (30%)
                type = 'MOUSE';
            } else {
                // 0.4 to 1.0 (60%)
                type = 'APPLE';
            }

            let x, y;
            let attempts = 0;

            do {
                x = Math.floor(Math.random() * GRID_SIZE);
                y = Math.floor(Math.random() * GRID_SIZE);
                attempts++;

                if (attempts >= MAX_FOOD_SPAWN_ATTEMPTS) {
                    break;
                }
            } while (snake.some(s => s.x === x && s.y === y));

            food = {
                x: x,
                y: y,
                type: type,
                points: FOOD_TYPES[type].points
            };
        }

        function checkLevelUp() {
            if (score >= LEVELS[currentLevel - 1].pointsNeeded && currentLevel < LEVELS.length) {
                currentLevel++;
                updateLevel();
                generateVegetation();
                initParticles();
                // Trigger expanding ring burst at screen centre
                levelUpBurst = { x: CANVAS_SIZE / 2, y: CANVAS_SIZE / 2, radius: 30, alpha: 1 };
                // CSS flash on the level indicator
                levelEl.classList.remove('level-flash');
                void levelEl.offsetWidth; // force reflow to restart animation
                levelEl.classList.add('level-flash');
                announce('Level ' + currentLevel + '!');
            }
        }

        function updateScore() {
            scoreEl.textContent = score;
            // Score pop animation
            scoreEl.classList.remove('score-pop');
            void scoreEl.offsetWidth; // force reflow
            scoreEl.classList.add('score-pop');
            if (score > highScore) {
                highScore = score;
                saveHighScore(highScore);
                highScoreEl.textContent = highScore;
            }
        }

        function updateLevel() {
            levelEl.textContent = currentLevel;
        }

        function gameOver() {
            gameState = 'gameover';
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            deathFlashAlpha = 0.65; // trigger red flash
            finalScoreEl.textContent = score;
            finalLevelEl.textContent = currentLevel;
            // Show game over screen after the flash draws one frame
            requestAnimationFrame(() => {
                draw();
                setTimeout(() => {
                    gameOverScreen.style.display = 'block';
                    startIdleAnimation();
                }, 400);
            });
            announce('Game over. Final score: ' + score);
        }

        // ==================== ERROR DISPLAY ====================
        function showErrorOverlay() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.88)';
            ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            ctx.shadowBlur = 0;
            ctx.textAlign = 'center';
            ctx.fillStyle = '#ff4444';
            ctx.font = 'bold 26px Segoe UI, sans-serif';
            ctx.fillText('Something went wrong', CANVAS_SIZE / 2, CANVAS_SIZE / 2 - 24);
            ctx.fillStyle = '#cccccc';
            ctx.font = '16px Segoe UI, sans-serif';
            ctx.fillText('Please refresh the page to restart.', CANVAS_SIZE / 2, CANVAS_SIZE / 2 + 18);
        }

        // ==================== GAME LOOP (requestAnimationFrame) ====================
        function gameLoop(timestamp) {
            if (gameState !== 'playing') return;

            try {
                if (!lastUpdateTime) {
                    lastUpdateTime = timestamp;
                }

                const deltaTime = timestamp - lastUpdateTime;
                lastUpdateTime = timestamp;
                accumulatedTime += deltaTime;

                const currentSpeed = LEVELS[currentLevel - 1].speed;

                while (accumulatedTime >= currentSpeed) {
                    update();
                    accumulatedTime -= currentSpeed;

                    if (gameState !== 'playing') {
                        return;
                    }
                }

                draw();
                animationId = requestAnimationFrame(gameLoop);
            } catch (err) {
                gameState = 'gameover';
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
                showErrorOverlay();
                announce('An error occurred. Please refresh the page.');
            }
        }

        function update() {
            direction.x = nextDirection.x;
            direction.y = nextDirection.y;

            let headX = snake[0].x + direction.x;
            let headY = snake[0].y + direction.y;

            // Wrap around
            if (headX < 0) headX = GRID_SIZE - 1;
            if (headX >= GRID_SIZE) headX = 0;
            if (headY < 0) headY = GRID_SIZE - 1;
            if (headY >= GRID_SIZE) headY = 0;

            // Self collision
            if (snake.some(s => s.x === headX && s.y === headY)) {
                gameOver();
                return;
            }

            snake.unshift({ x: headX, y: headY });

            // Failsafe: ensure food exists
            if (food.x === undefined || food.y === undefined) {
                spawnFood();
            }

            if (headX === food.x && headY === food.y) {
                score += food.points;
                updateScore();
                spawnFood();
                checkLevelUp();
            } else {
                snake.pop();
            }

            animationFrame++;
            updateParticles();
        }

        function drawLevelUpBurst() {
            if (!levelUpBurst) return;
            const b = levelUpBurst;
            ctx.save();
            ctx.globalAlpha = b.alpha;
            ctx.strokeStyle = '#7CFC00';
            ctx.lineWidth = 4;
            ctx.shadowColor = '#7CFC00';
            ctx.shadowBlur = 20;
            ctx.beginPath();
            ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();

            b.radius += 10;
            b.alpha -= 0.045;
            if (b.alpha <= 0) levelUpBurst = null;
        }

        function drawDeathFlash() {
            if (deathFlashAlpha <= 0) return;
            ctx.save();
            ctx.globalAlpha = deathFlashAlpha;
            ctx.fillStyle = '#ff1111';
            ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            ctx.restore();
            deathFlashAlpha -= 0.06;
            if (deathFlashAlpha < 0) deathFlashAlpha = 0;
        }

        function draw() {
            drawBackground();
            drawParticles();
            drawRealisticSnake();
            drawRealisticFood();
            drawLevelUpBurst();
            drawDeathFlash();

            if (gameState === 'paused') {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
                ctx.fillStyle = '#7CFC00';
                ctx.font = 'bold 50px Segoe UI';
                ctx.textAlign = 'center';
                ctx.shadowColor = 'rgba(0, 0, 0, 0.8)';
                ctx.shadowBlur = 15;
                ctx.fillText('PAUSED', CANVAS_SIZE / 2, CANVAS_SIZE / 2);
                ctx.shadowBlur = 0;
            }
        }

        // ==================== IDLE ANIMATION ====================
        function startIdleAnimation() {
            if (idleAnimationId) return;

            let lastIdleTime = 0;

            function idleLoop(timestamp) {
                if (gameState === 'playing') {
                    idleAnimationId = null;
                    return;
                }

                if (timestamp - lastIdleTime >= IDLE_FRAME_INTERVAL) {
                    animationFrame++;
                    updateParticles();
                    draw();
                    lastIdleTime = timestamp;
                }

                idleAnimationId = requestAnimationFrame(idleLoop);
            }

            idleAnimationId = requestAnimationFrame(idleLoop);
        }

        function stopIdleAnimation() {
            if (idleAnimationId) {
                cancelAnimationFrame(idleAnimationId);
                idleAnimationId = null;
            }
        }

        // ==================== GAME CONTROLS ====================
        function startGame() {
            snake = [
                { x: 12, y: 12 },
                { x: 11, y: 12 },
                { x: 10, y: 12 }
            ];

            direction = { x: 1, y: 0 };
            nextDirection = { x: 1, y: 0 };
            score = 0;
            currentLevel = 1;
            gameState = 'playing';
            animationFrame = 0;
            lastUpdateTime = 0;
            accumulatedTime = 0;
            levelUpBurst = null;
            deathFlashAlpha = 0;

            startScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';

            updateScore();
            updateLevel();
            generateVegetation();
            initParticles();
            spawnFood();

            stopIdleAnimation();

            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            animationId = requestAnimationFrame(gameLoop);
            announce('Game started');
        }

        function togglePause() {
            if (gameState === 'playing') {
                gameState = 'paused';
                if (animationId) {
                    cancelAnimationFrame(animationId);
                    animationId = null;
                }
                draw();
                startIdleAnimation();
                announce('Game paused');
            } else if (gameState === 'paused') {
                gameState = 'playing';
                stopIdleAnimation();
                lastUpdateTime = 0;
                accumulatedTime = 0;
                animationId = requestAnimationFrame(gameLoop);
                announce('Game resumed');
            }
        }

        function resetGame() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            stopIdleAnimation();

            gameState = 'start';
            currentLevel = 1;
            startScreen.style.display = 'block';
            gameOverScreen.style.display = 'none';
            generateVegetation();
            initParticles();
            startIdleAnimation();
            announce('Game reset');
        }

        // ==================== EVENT HANDLERS ====================
        function handleKeydown(e) {
            if (e.code === 'Space') {
                e.preventDefault();
                if (gameState === 'start' || gameState === 'gameover') {
                    startGame();
                } else if (gameState === 'playing' || gameState === 'paused') {
                    togglePause();
                }
                return;
            }

            if (gameState !== 'playing') return;

            switch (e.key) {
                case 'ArrowUp':
                    e.preventDefault();
                    if (direction.y === 0) nextDirection = { x: 0, y: -1 };
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    if (direction.y === 0) nextDirection = { x: 0, y: 1 };
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    if (direction.x === 0) nextDirection = { x: -1, y: 0 };
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    if (direction.x === 0) nextDirection = { x: 1, y: 0 };
                    break;
            }
        }

        function handleTouchStart(e) {
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
        }

        function handleTouchEnd(e) {
            if (!touchStartX || !touchStartY) return;

            const touch = e.changedTouches[0];
            const deltaX = touch.clientX - touchStartX;
            const deltaY = touch.clientY - touchStartY;

            touchStartX = 0;
            touchStartY = 0;

            // Check if it's a tap (not a swipe)
            if (Math.abs(deltaX) < SWIPE_THRESHOLD && Math.abs(deltaY) < SWIPE_THRESHOLD) {
                if (gameState === 'start' || gameState === 'gameover') {
                    startGame();
                }
                return;
            }

            if (gameState !== 'playing') return;

            // Determine swipe direction
            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                // Horizontal swipe
                if (deltaX > SWIPE_THRESHOLD && direction.x === 0) {
                    nextDirection = { x: 1, y: 0 };
                } else if (deltaX < -SWIPE_THRESHOLD && direction.x === 0) {
                    nextDirection = { x: -1, y: 0 };
                }
            } else {
                // Vertical swipe
                if (deltaY > SWIPE_THRESHOLD && direction.y === 0) {
                    nextDirection = { x: 0, y: 1 };
                } else if (deltaY < -SWIPE_THRESHOLD && direction.y === 0) {
                    nextDirection = { x: 0, y: -1 };
                }
            }
        }

        // Attach event listeners
        document.addEventListener('keydown', handleKeydown);
        canvas.addEventListener('touchstart', handleTouchStart, { passive: true });
        canvas.addEventListener('touchend', handleTouchEnd, { passive: true });

        startBtn.addEventListener('click', startGame);
        pauseBtn.addEventListener('click', togglePause);
        restartBtn.addEventListener('click', resetGame);

        // ==================== INITIAL SETUP ====================
        generateVegetation();
        initParticles();
        draw();
        startIdleAnimation();

    })();
    </script>
</body>
</html>
